<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.xtuples.xtuples API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.xtuples.xtuples</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ---------------------------------------------------------------

import abc
import typing
import dataclasses
import collections

import operator
import itertools
import functools

# ---------------------------------------------------------------

# NOTE: at worst, not worse, than an un-optimised canonical solution

# where I cribbed from the itertools recipes (and other python docs), all credit to the original authors.

# where i didn&#39;t, i probably should have.

# ---------------------------------------------------------------

REGISTRY = {}

# ---------------------------------------------------------------

def pipe(f, obj, *args, at = None, discard=False, **kwargs):
    if at is None:
        res = f(obj, *args, **kwargs)
    elif isinstance(at, int):
        res = f(*args[:at], obj, *args[at:], **kwargs)
    elif isinstance(at, str):
        res = f(*args, **{at: obj}, **kwargs)
    else:
        assert False, at
    if not discard:
        return res
    return obj

# ---------------------------------------------------------------


# TODO: some kind of validation placeholder?
# called in init, eg. quarter in [1 .. 4]

class nTuple(abc.ABC):

    @abc.abstractmethod
    def __abstract__(self):
        # NOTE: here to prevent initialise instances of this
        # but rather use the decorator and typing.NamedTuple
        return

    @staticmethod
    def pipe(obj, f, *args, at = None, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; example = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; example.pipe(lambda a, b: a, None)
        Example(x=1, s=&#39;a&#39;, it=iTuple())
        &gt;&gt;&gt; example.pipe(lambda a, b: a, None, at = 1)
        &gt;&gt;&gt; example.pipe(lambda a, b: a, None, at = &#39;b&#39;)
        &gt;&gt;&gt; example.pipe(lambda a, b: a, a=None, at = &#39;b&#39;)
        &gt;&gt;&gt; example.pipe(lambda a, b: a, b=None, at = &#39;a&#39;)
        Example(x=1, s=&#39;a&#39;, it=iTuple())
        &gt;&gt;&gt; example.pipe(lambda a, b: a, None, at = 0)
        Example(x=1, s=&#39;a&#39;, it=iTuple())
        &#34;&#34;&#34;
        return pipe(f, obj, *args, at = at, **kwargs)

    @staticmethod
    def partial(obj, f, *args, **kwargs):
        return functools.partial(f, obj, *args, **kwargs)

    @classmethod
    def is_subclass(cls, t):
        &#34;&#34;&#34;
        &gt;&gt;&gt; nTuple.is_subclass(tuple)
        False
        &gt;&gt;&gt; nTuple.is_subclass(Example(1, &#34;a&#34;))
        False
        &gt;&gt;&gt; nTuple.is_subclass(Example)
        True
        &#34;&#34;&#34;
        try:
            is_sub = issubclass(t, tuple)
        except:
            is_sub = False
        return (
            is_sub and
            hasattr(t, &#34;cls&#34;) and
            hasattr(t, &#34;pipe&#34;) and
            hasattr(t, &#34;partial&#34;)
        )

    @classmethod
    def is_instance(cls, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; nTuple.is_instance(tuple)
        False
        &gt;&gt;&gt; nTuple.is_instance(Example)
        False
        &gt;&gt;&gt; nTuple.is_instance(Example(1, &#34;a&#34;))
        True
        &#34;&#34;&#34;
        return (
            cls.is_subclass(type(obj)) and
            hasattr(obj, &#39;_asdict&#39;) and
            hasattr(obj, &#39;_fields&#39;)
        )


    @staticmethod
    def annotations(obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; ex.pipe(ex.cls.annotations)
        {&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;s&#39;: &lt;class &#39;str&#39;&gt;, &#39;it&#39;: &lt;class &#39;xtuples.xtuples.iTuple&#39;&gt;}
        &#34;&#34;&#34;
        return fDict(obj.__annotations__)

    @classmethod
    def as_dict(cls, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; ex.pipe(ex.cls.as_dict)
        {&#39;x&#39;: 1, &#39;s&#39;: &#39;a&#39;, &#39;it&#39;: iTuple()}
        &#34;&#34;&#34;
        return fDict(obj._asdict())

    @classmethod
    def decorate(meta, cls):
        if cls.__name__ in REGISTRY:
            print(&#34;NOTE, re-registering: {}&#34;.format(cls.__name__))
        cls.pipe = meta.pipe
        cls.partial = meta.partial
        cls.cls = meta
        REGISTRY[cls.__name__] = cls
        return cls

    @classmethod
    def replace(cls, *ks):
        def f(obj, *vs):
            return obj._replace(**{k: v for k, v in zip(ks, vs)})
        return f

# ---------------------------------------------------------------

class fDict(collections.UserDict):
    __slots__ = ()

    data: dict

    def pipe(self, f, *args, at=None, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).pipe(lambda d: d.map_values(
        ...     lambda v: v + 1
        ... ))
        {0: 2}
        &#34;&#34;&#34;
        res = pipe(f, self, *args, at = at, **kwargs)
        if isinstance(res, dict):
            return fDict(res)
        return res

    def partial(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; f = fDict({0: 1}).partial(
        ...     lambda d, n: d.map_values(lambda v: v + n)
        ... )
        &gt;&gt;&gt; f(1)
        {0: 2}
        &gt;&gt;&gt; f(2)
        {0: 3}
        &#34;&#34;&#34;
        return functools.partial(f, self, *args, **kwargs)

    def keys_tuple(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).keys_tuple()
        iTuple(0)
        &#34;&#34;&#34;
        return iTuple.from_keys(self)

    def values_tuple(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).values_tuple()
        iTuple(1)
        &#34;&#34;&#34;
        return iTuple.from_values(self)
    
    def items_tuple(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).items_tuple()
        iTuple((0, 1))
        &#34;&#34;&#34;
        return iTuple.from_items(self)

    # NOTE: we have separate map implementations 
    # as they are constant size, dict to dict
    # other iterator functions should use iTuple (from the above)

    def map_keys(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).map_keys(lambda v: v + 1)
        {1: 1}
        &#34;&#34;&#34;
        return fDict(
            (f(k, *args, **kwargs), v) for k, v in self.items()
        )

    def map_values(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).map_values(lambda v: v + 1)
        {0: 2}
        &#34;&#34;&#34;
        return fDict(
            (k, f(v, *args, **kwargs)) for k, v in self.items()
        )

    def map_items(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).map_items(lambda k, v: (v, k))
        {1: 0}
        &#34;&#34;&#34;
        return fDict(
            f(k, v, *args, **kwargs) for k, v in self.items()
        )

    def invert(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).invert()
        {1: 0}
        &#34;&#34;&#34;
        return fDict((v, k) for k, v in self.items())

# ---------------------------------------------------------------

@dataclasses.dataclass(init = False, repr=True)
class iTuple(collections.UserList, tuple): # type: ignore
    __slots__ = ()

    data: tuple # type: ignore

    # -----

    @staticmethod
    def __new__(cls, data = None):
        # NOTE: we use cls not array
        # so sub-classing *does* change identity
        if isinstance(data, cls):
            return data
        return super().__new__(cls, data=data)
    
    def __init__(self, data = None):
        # TODO: option for lazy init?
        self.data = (
            tuple() if data is None
            else data if isinstance(data, tuple)
            else tuple(data)
        )

    def __repr__(self):
        s = super().__repr__()
        return &#34;{}({})&#34;.format(
            type(self).__name__,
            s[1:-2 if s[-2] == &#34;,&#34; else -1],
        )

    def __hash__(self):
        return hash(self.data)

    @classmethod
    def decorate(meta, cls):
        if cls.__name__ in REGISTRY:
            print(&#34;NOTE, re-registering: {}&#34;.format(cls.__name__))
        REGISTRY[cls.__name__] = cls
        return cls

    # -----

    @classmethod
    def range(cls, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3)
        iTuple(0, 1, 2)
        &#34;&#34;&#34;
        return cls(range(*args, **kwargs))

    @classmethod
    def from_keys(cls, d):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.from_keys({i: i + 1 for i in range(2)})
        iTuple(0, 1)
        &#34;&#34;&#34;
        return cls(d.keys())
        
    @classmethod
    def from_values(cls, d):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.from_values({i: i + 1 for i in range(2)})
        iTuple(1, 2)
        &#34;&#34;&#34;
        return cls(d.values())
        
    @classmethod
    def from_items(cls, d):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.from_items({i: i + 1 for i in range(2)})
        iTuple((0, 1), (1, 2))
        &#34;&#34;&#34;
        return cls(d.items())

    # -----

    def pipe(self, f, *args, at = None, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(2).pipe(lambda it: it)
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(2).pipe(
        ...     lambda it, v: it.map(lambda x: x * v), 2
        ... )
        iTuple(0, 2)
        &#34;&#34;&#34;
        return pipe(f, self, *args, at = at, **kwargs)

    def partial(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; f = iTuple.range(2).partial(
        ...     lambda it, v: it.map(lambda x: x * v)
        ... )
        &gt;&gt;&gt; f(2)
        iTuple(0, 2)
        &gt;&gt;&gt; f(3)
        iTuple(0, 3)
        &#34;&#34;&#34;
        return functools.partial(f, self, *args, **kwargs)

    # -----

    def __len__(self):
        return len(self.data)

    def __contains__(self, v):
        return v in self.data

    def len(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).len()
        3
        &#34;&#34;&#34;
        return len(self.data)

    def append(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).append(1)
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(1).append(1, 2)
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(1).append(1, 2, 3)
        iTuple(0, 1, 2, 3)
        &gt;&gt;&gt; iTuple.range(1).append(1, (2,))
        iTuple(0, 1, (2,))
        &#34;&#34;&#34;
        return iTuple(data=(*self.data, value, *values))

    def prepend(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).prepend(1)
        iTuple(1, 0)
        &gt;&gt;&gt; iTuple.range(1).prepend(1, 2)
        iTuple(1, 2, 0)
        &gt;&gt;&gt; iTuple.range(1).prepend(1, 2, 3)
        iTuple(1, 2, 3, 0)
        &gt;&gt;&gt; iTuple.range(1).prepend(1, (2,))
        iTuple(1, (2,), 0)
        &#34;&#34;&#34;
        return iTuple(data=(value, *values, *self.data))

    def zip(self, *itrs, lazy = False, at = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple([[1, 1], [2, 2], [3, 3]]).zip()
        iTuple((1, 2, 3), (1, 2, 3))
        &gt;&gt;&gt; iTuple([iTuple.range(3), iTuple.range(1, 4)]).zip()
        iTuple((0, 1), (1, 2), (2, 3))
        &gt;&gt;&gt; iTuple.range(3).zip(iTuple.range(1, 4))
        iTuple((0, 1), (1, 2), (2, 3))
        &#34;&#34;&#34;
        if len(itrs) == 0:
            res = zip(*self)
        elif at is None:
            res = zip(self, *itrs)
        elif isinstance(at, int):
            res = zip(*itrs[:at], self, *itrs[at:])
        else:
            assert False, at
        return res if lazy else iTuple(data=res)

    def flatten(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).map(lambda x: [x]).flatten()
        iTuple(0, 1, 2)
        &#34;&#34;&#34;
        return iTuple(data=itertools.chain(*self))

    def extend(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).extend((1,))
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(1).extend([1])
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(1).extend([1], [2])
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(1).extend([1], [[2]])
        iTuple(0, 1, [2])
        &gt;&gt;&gt; iTuple.range(1).extend([1], [[2]], [2])
        iTuple(0, 1, [2], 2)
        &#34;&#34;&#34;
        return iTuple(data=itertools.chain.from_iterable(
            (self, value, *values)
        ))

    def pretend(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).pretend((1,))
        iTuple(1, 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1])
        iTuple(1, 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1], [2])
        iTuple(1, 2, 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]])
        iTuple(1, [2], 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]], [2])
        iTuple(1, [2], 2, 0)
        &#34;&#34;&#34;
        return iTuple(data=itertools.chain.from_iterable(
            (value, *values, self)
        ))

    def filter_eq(self, v, f = None, eq = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).filter_eq(1)
        iTuple(1)
        &#34;&#34;&#34;
        if f is None and eq is None:
            res = filter(lambda x: x == v, self)
        elif f is not None:
            res = filter(lambda x: f(x) == v, self)
        elif eq is not None:
            res = filter(lambda x: eq(x, v), self)
        else:
            res = filter(lambda x: eq(f(x), v), self)
        return res if lazy else type(self)(data=res)

    def filter(self, f, eq = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).filter(lambda x: x &gt; 1)
        iTuple(2)
        &#34;&#34;&#34;
        # res = []
        # for v in self.iter():
        #     if f(v):
        #         res.append(v)
        return iTuple(data=(
            v for v in self.iter() if f(v)
        ))
        # return self.filter_eq(True, f = f, eq = eq, lazy = lazy)

    def map(self, f, *iterables, at = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).map(lambda x: x * 2)
        iTuple(0, 2, 4)
        &#34;&#34;&#34;
        # if lazy and at is None:
        #     return map(f, self.data, *iterables)
        if at is None:
            return iTuple(data = map(f, self.data, *iterables))
        elif isinstance(at, int):
            return iTuple(data = map(
                f, *iterables[:at], self.data, *iterables[at:]
            ))
        else:
            assert False, at

    # args, kwargs
    def mapstar(self, f):
        return iTuple(data=itertools.starmap(f, self.data))

    def get(self, i):
        return self.data[i]

    def __getitem__(self, i):
        return self.data[i]

    def __iter__(self):
        return iter(self.data)

    def iter(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; for x in iTuple.range(3).iter(): print(x)
        0
        1
        2
        &#34;&#34;&#34;
        return iter(self.data)

    def enumerate(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).enumerate()
        iTuple((0, 0), (1, 1), (2, 2))
        &#34;&#34;&#34;
        # TODO: allow lazy
        return iTuple(enumerate(self))

    def groupby(
        self, 
        f, 
        lazy = False, 
        keys = False,
        pipe= None,
    ):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).groupby(lambda x: x &lt; 2)
        iTuple((0, 1), (2,))
        &gt;&gt;&gt; iTuple.range(3).groupby(
        ...    lambda x: x &lt; 2, keys=True, pipe=fDict
        ... )
        {True: (0, 1), False: (2,)}
        &#34;&#34;&#34;
        # TODO: lazy no keys
        res = itertools.groupby(self, key=f)
        if lazy and keys and pipe is None:
            return res
        if pipe is None:
            pipe = iTuple
        if keys:
            return pipe((k, tuple(g),) for k, g in res)
        else:
            return pipe(tuple(g) for k, g in res)

    def first(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).first()
        0
        &#34;&#34;&#34;
        return self[0]
    
    def last(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).last()
        2
        &#34;&#34;&#34;
        return self[-1]

    def first_where(self, f):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).first_where(lambda v: v &gt; 0)
        1
        &#34;&#34;&#34;
        for v in self:
            if f(v):
                return v
        return None

    def last_where(self, f):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).last_where(lambda v: v &lt; 2)
        1
        &#34;&#34;&#34;
        for v in reversed(self):
            if f(v):
                return v
        return None

    def take(self, n):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).take(2)
        iTuple(0, 1)
        &#34;&#34;&#34;
        return self[:n]

    def tail(self, n):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).tail(2)
        iTuple(1, 2)
        &#34;&#34;&#34;
        return self[-n:]

    def reverse(self, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).reverse()
        iTuple(2, 1, 0)
        &#34;&#34;&#34;
        if lazy:
            return reversed(self)
        return type(self)(data=reversed(self))

    def take_while(self, f, n = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).take_while(lambda v: v &lt; 1)
        iTuple(0)
        &#34;&#34;&#34;
        def iter():
            i = 0
            for v in self:
                if f(v) and (n is None or i &lt; n):
                    yield v
                    i += 1
                else:
                    return
        res = iter()
        return res if lazy else type(self)(data=res)

    def tail_while(self, f, n = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).tail_while(lambda v: v &gt; 1)
        iTuple(2)
        &#34;&#34;&#34;
        i = 0
        for v in reversed(self):
            if f(v) and (n is None or i &lt; n):
                i += 1
            else:
                break
        return self.tail(i)

    # NOTE: from as in, starting from first true
    # versus above, which is until first false
    def take_after(self, f, n = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1)
        iTuple(1, 2)
        &gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1, n = 1)
        iTuple(1)
        &#34;&#34;&#34;
        def iter():
            i = 0
            for v in self:
                if f(v):
                    pass
                elif n is None or i &lt; n:
                    yield v
                    i += 1
                else:
                    return
        res = iter()
        return res if lazy else type(self)(data=res)

    def tail_after(self, f, n = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2)
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2, 1)
        iTuple(1)
        &#34;&#34;&#34;
        l = 0
        r = 0
        for v in reversed(self):
            if not f(v):
                l += 1
            elif n is None or r &lt; n:
                r += 1
            else:
                break
        return self.tail(l + r).take(r)

    def islice(self, left = None, right = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(5).islice(1, 3)
        iTuple(1, 2)
        &#34;&#34;&#34;
        return self[left:right]

    def unique(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple([1, 1, 3, 2, 4, 2, 3]).unique()
        iTuple(1, 3, 2, 4)
        &#34;&#34;&#34;
        def iter():
            seen = set()
            seen_add = seen.add
            seen_contains = seen.__contains__
            for v in itertools.filterfalse(seen_contains, self):
                seen_add(v)
                yield v
        return type(self)(data=iter())
    
    def sort(self, f = lambda v: v):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).reverse().sort()
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).sort()
        iTuple(0, 1, 2)
        &#34;&#34;&#34;
        return type(self)(data=sorted(self, key = f))

    def accumulate(self, f, initial = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v)
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v, initial=0)
        iTuple(0, 0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).accumulate(operator.add)
        iTuple(0, 1, 3)
        &#34;&#34;&#34;
        if lazy:
            return itertools.accumulate(self, func=f, initial=initial)
        return iTuple(data=itertools.accumulate(
            self, func=f, initial=initial
        ))

    def foldcum(self, *args, initial=None, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).foldcum(lambda acc, v: v)
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).foldcum(operator.add)
        iTuple(0, 1, 3)
        &#34;&#34;&#34;
        # res = []
        # acc = initial
        # for x in self.iter():
        #     acc = f(acc, x)
        #     res.append(acc)
        # return iTuple(data=tuple(res))
        return self.accumulate(*args, **kwargs)

    def fold(self, f, initial=None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v)
        2
        &gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v, initial=0)
        2
        &gt;&gt;&gt; iTuple.range(3).fold(operator.add)
        3
        &#34;&#34;&#34;
        # acc = initial
        # for v in self.iter():
        #     acc = f(acc, v)
        # return iTuple(data=tuple(acc))
        if initial is not None:
            return functools.reduce(f, self, initial)
        else:
            return functools.reduce(f, self)

    # -----

    # combinatorics

    # -----

# ---------------------------------------------------------------

@nTuple.decorate
class _Example(typing.NamedTuple):
    &#34;&#34;&#34;
    &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
    &gt;&gt;&gt; ex
    Example(x=1, s=&#39;a&#39;, it=iTuple())
    &gt;&gt;&gt; ex.cls
    &lt;class &#39;xtuples.xtuples.nTuple&#39;&gt;
    &gt;&gt;&gt; ex.pipe(lambda nt: nt.x)
    1
    &gt;&gt;&gt; f = ex.partial(lambda nt, v: nt.x * v)
    &gt;&gt;&gt; f(2)
    2
    &gt;&gt;&gt; f(3)
    3
    &#34;&#34;&#34;
    # NOTE: cls, pipe, partial are mandatory boilerplate

    x: int
    s: str
    it: iTuple = iTuple([])

    @property
    def cls(self):
        ...

    def pipe(self, f, *args, at = None, **kwargs):
        ...

    def partial(self, f, *args, at = None, **kwargs):
        ...

# ---------------------------------------------------------------

# TODO: context manager to control
# if we add the type information when writing to json or not

# TODO: context mananger to control
# lazy default behaviour (ie. default to lazy or not)

__all__ = [
    &#34;iTuple&#34;,
    &#34;nTuple&#34;,
    &#34;fDict&#34;,
    # &#34;_Example&#34;,
]

# ---------------------------------------------------------------</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.xtuples.xtuples.fDict"><code class="flex name class">
<span>class <span class="ident">fDict</span></span>
<span>(</span><span>dict=None, /, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class fDict(collections.UserDict):
    __slots__ = ()

    data: dict

    def pipe(self, f, *args, at=None, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).pipe(lambda d: d.map_values(
        ...     lambda v: v + 1
        ... ))
        {0: 2}
        &#34;&#34;&#34;
        res = pipe(f, self, *args, at = at, **kwargs)
        if isinstance(res, dict):
            return fDict(res)
        return res

    def partial(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; f = fDict({0: 1}).partial(
        ...     lambda d, n: d.map_values(lambda v: v + n)
        ... )
        &gt;&gt;&gt; f(1)
        {0: 2}
        &gt;&gt;&gt; f(2)
        {0: 3}
        &#34;&#34;&#34;
        return functools.partial(f, self, *args, **kwargs)

    def keys_tuple(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).keys_tuple()
        iTuple(0)
        &#34;&#34;&#34;
        return iTuple.from_keys(self)

    def values_tuple(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).values_tuple()
        iTuple(1)
        &#34;&#34;&#34;
        return iTuple.from_values(self)
    
    def items_tuple(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).items_tuple()
        iTuple((0, 1))
        &#34;&#34;&#34;
        return iTuple.from_items(self)

    # NOTE: we have separate map implementations 
    # as they are constant size, dict to dict
    # other iterator functions should use iTuple (from the above)

    def map_keys(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).map_keys(lambda v: v + 1)
        {1: 1}
        &#34;&#34;&#34;
        return fDict(
            (f(k, *args, **kwargs), v) for k, v in self.items()
        )

    def map_values(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).map_values(lambda v: v + 1)
        {0: 2}
        &#34;&#34;&#34;
        return fDict(
            (k, f(v, *args, **kwargs)) for k, v in self.items()
        )

    def map_items(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).map_items(lambda k, v: (v, k))
        {1: 0}
        &#34;&#34;&#34;
        return fDict(
            f(k, v, *args, **kwargs) for k, v in self.items()
        )

    def invert(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).invert()
        {1: 0}
        &#34;&#34;&#34;
        return fDict((v, k) for k, v in self.items())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.UserDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="src.xtuples.xtuples.fDict.data"><code class="name">var <span class="ident">data</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.xtuples.xtuples.fDict.invert"><code class="name flex">
<span>def <span class="ident">invert</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).invert()
{1: 0}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).invert()
    {1: 0}
    &#34;&#34;&#34;
    return fDict((v, k) for k, v in self.items())</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.fDict.items_tuple"><code class="name flex">
<span>def <span class="ident">items_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).items_tuple()
iTuple((0, 1))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items_tuple(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).items_tuple()
    iTuple((0, 1))
    &#34;&#34;&#34;
    return iTuple.from_items(self)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.fDict.keys_tuple"><code class="name flex">
<span>def <span class="ident">keys_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).keys_tuple()
iTuple(0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys_tuple(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).keys_tuple()
    iTuple(0)
    &#34;&#34;&#34;
    return iTuple.from_keys(self)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.fDict.map_items"><code class="name flex">
<span>def <span class="ident">map_items</span></span>(<span>self, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).map_items(lambda k, v: (v, k))
{1: 0}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_items(self, f, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).map_items(lambda k, v: (v, k))
    {1: 0}
    &#34;&#34;&#34;
    return fDict(
        f(k, v, *args, **kwargs) for k, v in self.items()
    )</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.fDict.map_keys"><code class="name flex">
<span>def <span class="ident">map_keys</span></span>(<span>self, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).map_keys(lambda v: v + 1)
{1: 1}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_keys(self, f, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).map_keys(lambda v: v + 1)
    {1: 1}
    &#34;&#34;&#34;
    return fDict(
        (f(k, *args, **kwargs), v) for k, v in self.items()
    )</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.fDict.map_values"><code class="name flex">
<span>def <span class="ident">map_values</span></span>(<span>self, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).map_values(lambda v: v + 1)
{0: 2}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_values(self, f, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).map_values(lambda v: v + 1)
    {0: 2}
    &#34;&#34;&#34;
    return fDict(
        (k, f(v, *args, **kwargs)) for k, v in self.items()
    )</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.fDict.partial"><code class="name flex">
<span>def <span class="ident">partial</span></span>(<span>self, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; f = fDict({0: 1}).partial(
...     lambda d, n: d.map_values(lambda v: v + n)
... )
&gt;&gt;&gt; f(1)
{0: 2}
&gt;&gt;&gt; f(2)
{0: 3}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partial(self, f, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; f = fDict({0: 1}).partial(
    ...     lambda d, n: d.map_values(lambda v: v + n)
    ... )
    &gt;&gt;&gt; f(1)
    {0: 2}
    &gt;&gt;&gt; f(2)
    {0: 3}
    &#34;&#34;&#34;
    return functools.partial(f, self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.fDict.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, f, *args, at=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).pipe(lambda d: d.map_values(
...     lambda v: v + 1
... ))
{0: 2}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, f, *args, at=None, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).pipe(lambda d: d.map_values(
    ...     lambda v: v + 1
    ... ))
    {0: 2}
    &#34;&#34;&#34;
    res = pipe(f, self, *args, at = at, **kwargs)
    if isinstance(res, dict):
        return fDict(res)
    return res</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.fDict.values_tuple"><code class="name flex">
<span>def <span class="ident">values_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).values_tuple()
iTuple(1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values_tuple(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).values_tuple()
    iTuple(1)
    &#34;&#34;&#34;
    return iTuple.from_values(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.xtuples.xtuples.iTuple"><code class="flex name class">
<span>class <span class="ident">iTuple</span></span>
<span>(</span><span>data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>iTuple(data=None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass(init = False, repr=True)
class iTuple(collections.UserList, tuple): # type: ignore
    __slots__ = ()

    data: tuple # type: ignore

    # -----

    @staticmethod
    def __new__(cls, data = None):
        # NOTE: we use cls not array
        # so sub-classing *does* change identity
        if isinstance(data, cls):
            return data
        return super().__new__(cls, data=data)
    
    def __init__(self, data = None):
        # TODO: option for lazy init?
        self.data = (
            tuple() if data is None
            else data if isinstance(data, tuple)
            else tuple(data)
        )

    def __repr__(self):
        s = super().__repr__()
        return &#34;{}({})&#34;.format(
            type(self).__name__,
            s[1:-2 if s[-2] == &#34;,&#34; else -1],
        )

    def __hash__(self):
        return hash(self.data)

    @classmethod
    def decorate(meta, cls):
        if cls.__name__ in REGISTRY:
            print(&#34;NOTE, re-registering: {}&#34;.format(cls.__name__))
        REGISTRY[cls.__name__] = cls
        return cls

    # -----

    @classmethod
    def range(cls, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3)
        iTuple(0, 1, 2)
        &#34;&#34;&#34;
        return cls(range(*args, **kwargs))

    @classmethod
    def from_keys(cls, d):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.from_keys({i: i + 1 for i in range(2)})
        iTuple(0, 1)
        &#34;&#34;&#34;
        return cls(d.keys())
        
    @classmethod
    def from_values(cls, d):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.from_values({i: i + 1 for i in range(2)})
        iTuple(1, 2)
        &#34;&#34;&#34;
        return cls(d.values())
        
    @classmethod
    def from_items(cls, d):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.from_items({i: i + 1 for i in range(2)})
        iTuple((0, 1), (1, 2))
        &#34;&#34;&#34;
        return cls(d.items())

    # -----

    def pipe(self, f, *args, at = None, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(2).pipe(lambda it: it)
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(2).pipe(
        ...     lambda it, v: it.map(lambda x: x * v), 2
        ... )
        iTuple(0, 2)
        &#34;&#34;&#34;
        return pipe(f, self, *args, at = at, **kwargs)

    def partial(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; f = iTuple.range(2).partial(
        ...     lambda it, v: it.map(lambda x: x * v)
        ... )
        &gt;&gt;&gt; f(2)
        iTuple(0, 2)
        &gt;&gt;&gt; f(3)
        iTuple(0, 3)
        &#34;&#34;&#34;
        return functools.partial(f, self, *args, **kwargs)

    # -----

    def __len__(self):
        return len(self.data)

    def __contains__(self, v):
        return v in self.data

    def len(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).len()
        3
        &#34;&#34;&#34;
        return len(self.data)

    def append(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).append(1)
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(1).append(1, 2)
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(1).append(1, 2, 3)
        iTuple(0, 1, 2, 3)
        &gt;&gt;&gt; iTuple.range(1).append(1, (2,))
        iTuple(0, 1, (2,))
        &#34;&#34;&#34;
        return iTuple(data=(*self.data, value, *values))

    def prepend(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).prepend(1)
        iTuple(1, 0)
        &gt;&gt;&gt; iTuple.range(1).prepend(1, 2)
        iTuple(1, 2, 0)
        &gt;&gt;&gt; iTuple.range(1).prepend(1, 2, 3)
        iTuple(1, 2, 3, 0)
        &gt;&gt;&gt; iTuple.range(1).prepend(1, (2,))
        iTuple(1, (2,), 0)
        &#34;&#34;&#34;
        return iTuple(data=(value, *values, *self.data))

    def zip(self, *itrs, lazy = False, at = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple([[1, 1], [2, 2], [3, 3]]).zip()
        iTuple((1, 2, 3), (1, 2, 3))
        &gt;&gt;&gt; iTuple([iTuple.range(3), iTuple.range(1, 4)]).zip()
        iTuple((0, 1), (1, 2), (2, 3))
        &gt;&gt;&gt; iTuple.range(3).zip(iTuple.range(1, 4))
        iTuple((0, 1), (1, 2), (2, 3))
        &#34;&#34;&#34;
        if len(itrs) == 0:
            res = zip(*self)
        elif at is None:
            res = zip(self, *itrs)
        elif isinstance(at, int):
            res = zip(*itrs[:at], self, *itrs[at:])
        else:
            assert False, at
        return res if lazy else iTuple(data=res)

    def flatten(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).map(lambda x: [x]).flatten()
        iTuple(0, 1, 2)
        &#34;&#34;&#34;
        return iTuple(data=itertools.chain(*self))

    def extend(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).extend((1,))
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(1).extend([1])
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(1).extend([1], [2])
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(1).extend([1], [[2]])
        iTuple(0, 1, [2])
        &gt;&gt;&gt; iTuple.range(1).extend([1], [[2]], [2])
        iTuple(0, 1, [2], 2)
        &#34;&#34;&#34;
        return iTuple(data=itertools.chain.from_iterable(
            (self, value, *values)
        ))

    def pretend(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).pretend((1,))
        iTuple(1, 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1])
        iTuple(1, 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1], [2])
        iTuple(1, 2, 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]])
        iTuple(1, [2], 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]], [2])
        iTuple(1, [2], 2, 0)
        &#34;&#34;&#34;
        return iTuple(data=itertools.chain.from_iterable(
            (value, *values, self)
        ))

    def filter_eq(self, v, f = None, eq = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).filter_eq(1)
        iTuple(1)
        &#34;&#34;&#34;
        if f is None and eq is None:
            res = filter(lambda x: x == v, self)
        elif f is not None:
            res = filter(lambda x: f(x) == v, self)
        elif eq is not None:
            res = filter(lambda x: eq(x, v), self)
        else:
            res = filter(lambda x: eq(f(x), v), self)
        return res if lazy else type(self)(data=res)

    def filter(self, f, eq = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).filter(lambda x: x &gt; 1)
        iTuple(2)
        &#34;&#34;&#34;
        # res = []
        # for v in self.iter():
        #     if f(v):
        #         res.append(v)
        return iTuple(data=(
            v for v in self.iter() if f(v)
        ))
        # return self.filter_eq(True, f = f, eq = eq, lazy = lazy)

    def map(self, f, *iterables, at = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).map(lambda x: x * 2)
        iTuple(0, 2, 4)
        &#34;&#34;&#34;
        # if lazy and at is None:
        #     return map(f, self.data, *iterables)
        if at is None:
            return iTuple(data = map(f, self.data, *iterables))
        elif isinstance(at, int):
            return iTuple(data = map(
                f, *iterables[:at], self.data, *iterables[at:]
            ))
        else:
            assert False, at

    # args, kwargs
    def mapstar(self, f):
        return iTuple(data=itertools.starmap(f, self.data))

    def get(self, i):
        return self.data[i]

    def __getitem__(self, i):
        return self.data[i]

    def __iter__(self):
        return iter(self.data)

    def iter(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; for x in iTuple.range(3).iter(): print(x)
        0
        1
        2
        &#34;&#34;&#34;
        return iter(self.data)

    def enumerate(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).enumerate()
        iTuple((0, 0), (1, 1), (2, 2))
        &#34;&#34;&#34;
        # TODO: allow lazy
        return iTuple(enumerate(self))

    def groupby(
        self, 
        f, 
        lazy = False, 
        keys = False,
        pipe= None,
    ):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).groupby(lambda x: x &lt; 2)
        iTuple((0, 1), (2,))
        &gt;&gt;&gt; iTuple.range(3).groupby(
        ...    lambda x: x &lt; 2, keys=True, pipe=fDict
        ... )
        {True: (0, 1), False: (2,)}
        &#34;&#34;&#34;
        # TODO: lazy no keys
        res = itertools.groupby(self, key=f)
        if lazy and keys and pipe is None:
            return res
        if pipe is None:
            pipe = iTuple
        if keys:
            return pipe((k, tuple(g),) for k, g in res)
        else:
            return pipe(tuple(g) for k, g in res)

    def first(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).first()
        0
        &#34;&#34;&#34;
        return self[0]
    
    def last(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).last()
        2
        &#34;&#34;&#34;
        return self[-1]

    def first_where(self, f):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).first_where(lambda v: v &gt; 0)
        1
        &#34;&#34;&#34;
        for v in self:
            if f(v):
                return v
        return None

    def last_where(self, f):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).last_where(lambda v: v &lt; 2)
        1
        &#34;&#34;&#34;
        for v in reversed(self):
            if f(v):
                return v
        return None

    def take(self, n):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).take(2)
        iTuple(0, 1)
        &#34;&#34;&#34;
        return self[:n]

    def tail(self, n):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).tail(2)
        iTuple(1, 2)
        &#34;&#34;&#34;
        return self[-n:]

    def reverse(self, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).reverse()
        iTuple(2, 1, 0)
        &#34;&#34;&#34;
        if lazy:
            return reversed(self)
        return type(self)(data=reversed(self))

    def take_while(self, f, n = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).take_while(lambda v: v &lt; 1)
        iTuple(0)
        &#34;&#34;&#34;
        def iter():
            i = 0
            for v in self:
                if f(v) and (n is None or i &lt; n):
                    yield v
                    i += 1
                else:
                    return
        res = iter()
        return res if lazy else type(self)(data=res)

    def tail_while(self, f, n = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).tail_while(lambda v: v &gt; 1)
        iTuple(2)
        &#34;&#34;&#34;
        i = 0
        for v in reversed(self):
            if f(v) and (n is None or i &lt; n):
                i += 1
            else:
                break
        return self.tail(i)

    # NOTE: from as in, starting from first true
    # versus above, which is until first false
    def take_after(self, f, n = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1)
        iTuple(1, 2)
        &gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1, n = 1)
        iTuple(1)
        &#34;&#34;&#34;
        def iter():
            i = 0
            for v in self:
                if f(v):
                    pass
                elif n is None or i &lt; n:
                    yield v
                    i += 1
                else:
                    return
        res = iter()
        return res if lazy else type(self)(data=res)

    def tail_after(self, f, n = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2)
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2, 1)
        iTuple(1)
        &#34;&#34;&#34;
        l = 0
        r = 0
        for v in reversed(self):
            if not f(v):
                l += 1
            elif n is None or r &lt; n:
                r += 1
            else:
                break
        return self.tail(l + r).take(r)

    def islice(self, left = None, right = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(5).islice(1, 3)
        iTuple(1, 2)
        &#34;&#34;&#34;
        return self[left:right]

    def unique(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple([1, 1, 3, 2, 4, 2, 3]).unique()
        iTuple(1, 3, 2, 4)
        &#34;&#34;&#34;
        def iter():
            seen = set()
            seen_add = seen.add
            seen_contains = seen.__contains__
            for v in itertools.filterfalse(seen_contains, self):
                seen_add(v)
                yield v
        return type(self)(data=iter())
    
    def sort(self, f = lambda v: v):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).reverse().sort()
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).sort()
        iTuple(0, 1, 2)
        &#34;&#34;&#34;
        return type(self)(data=sorted(self, key = f))

    def accumulate(self, f, initial = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v)
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v, initial=0)
        iTuple(0, 0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).accumulate(operator.add)
        iTuple(0, 1, 3)
        &#34;&#34;&#34;
        if lazy:
            return itertools.accumulate(self, func=f, initial=initial)
        return iTuple(data=itertools.accumulate(
            self, func=f, initial=initial
        ))

    def foldcum(self, *args, initial=None, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).foldcum(lambda acc, v: v)
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).foldcum(operator.add)
        iTuple(0, 1, 3)
        &#34;&#34;&#34;
        # res = []
        # acc = initial
        # for x in self.iter():
        #     acc = f(acc, x)
        #     res.append(acc)
        # return iTuple(data=tuple(res))
        return self.accumulate(*args, **kwargs)

    def fold(self, f, initial=None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v)
        2
        &gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v, initial=0)
        2
        &gt;&gt;&gt; iTuple.range(3).fold(operator.add)
        3
        &#34;&#34;&#34;
        # acc = initial
        # for v in self.iter():
        #     acc = f(acc, v)
        # return iTuple(data=tuple(acc))
        if initial is not None:
            return functools.reduce(f, self, initial)
        else:
            return functools.reduce(f, self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.UserList</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li>builtins.tuple</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="src.xtuples.xtuples.iTuple.data"><code class="name">var <span class="ident">data</span> : tuple</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="src.xtuples.xtuples.iTuple.decorate"><code class="name flex">
<span>def <span class="ident">decorate</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def decorate(meta, cls):
    if cls.__name__ in REGISTRY:
        print(&#34;NOTE, re-registering: {}&#34;.format(cls.__name__))
    REGISTRY[cls.__name__] = cls
    return cls</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.from_items"><code class="name flex">
<span>def <span class="ident">from_items</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.from_items({i: i + 1 for i in range(2)})
iTuple((0, 1), (1, 2))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_items(cls, d):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.from_items({i: i + 1 for i in range(2)})
    iTuple((0, 1), (1, 2))
    &#34;&#34;&#34;
    return cls(d.items())</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.from_keys"><code class="name flex">
<span>def <span class="ident">from_keys</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.from_keys({i: i + 1 for i in range(2)})
iTuple(0, 1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_keys(cls, d):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.from_keys({i: i + 1 for i in range(2)})
    iTuple(0, 1)
    &#34;&#34;&#34;
    return cls(d.keys())</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.from_values"><code class="name flex">
<span>def <span class="ident">from_values</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.from_values({i: i + 1 for i in range(2)})
iTuple(1, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_values(cls, d):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.from_values({i: i + 1 for i in range(2)})
    iTuple(1, 2)
    &#34;&#34;&#34;
    return cls(d.values())</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3)
iTuple(0, 1, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def range(cls, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3)
    iTuple(0, 1, 2)
    &#34;&#34;&#34;
    return cls(range(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.xtuples.xtuples.iTuple.accumulate"><code class="name flex">
<span>def <span class="ident">accumulate</span></span>(<span>self, f, initial=None, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v)
iTuple(0, 1, 2)
&gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v, initial=0)
iTuple(0, 0, 1, 2)
&gt;&gt;&gt; iTuple.range(3).accumulate(operator.add)
iTuple(0, 1, 3)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accumulate(self, f, initial = None, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v)
    iTuple(0, 1, 2)
    &gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v, initial=0)
    iTuple(0, 0, 1, 2)
    &gt;&gt;&gt; iTuple.range(3).accumulate(operator.add)
    iTuple(0, 1, 3)
    &#34;&#34;&#34;
    if lazy:
        return itertools.accumulate(self, func=f, initial=initial)
    return iTuple(data=itertools.accumulate(
        self, func=f, initial=initial
    ))</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, value, *values)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(1).append(1)
iTuple(0, 1)
&gt;&gt;&gt; iTuple.range(1).append(1, 2)
iTuple(0, 1, 2)
&gt;&gt;&gt; iTuple.range(1).append(1, 2, 3)
iTuple(0, 1, 2, 3)
&gt;&gt;&gt; iTuple.range(1).append(1, (2,))
iTuple(0, 1, (2,))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, value, *values):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(1).append(1)
    iTuple(0, 1)
    &gt;&gt;&gt; iTuple.range(1).append(1, 2)
    iTuple(0, 1, 2)
    &gt;&gt;&gt; iTuple.range(1).append(1, 2, 3)
    iTuple(0, 1, 2, 3)
    &gt;&gt;&gt; iTuple.range(1).append(1, (2,))
    iTuple(0, 1, (2,))
    &#34;&#34;&#34;
    return iTuple(data=(*self.data, value, *values))</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.enumerate"><code class="name flex">
<span>def <span class="ident">enumerate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).enumerate()
iTuple((0, 0), (1, 1), (2, 2))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enumerate(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).enumerate()
    iTuple((0, 0), (1, 1), (2, 2))
    &#34;&#34;&#34;
    # TODO: allow lazy
    return iTuple(enumerate(self))</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, value, *values)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(1).extend((1,))
iTuple(0, 1)
&gt;&gt;&gt; iTuple.range(1).extend([1])
iTuple(0, 1)
&gt;&gt;&gt; iTuple.range(1).extend([1], [2])
iTuple(0, 1, 2)
&gt;&gt;&gt; iTuple.range(1).extend([1], [[2]])
iTuple(0, 1, [2])
&gt;&gt;&gt; iTuple.range(1).extend([1], [[2]], [2])
iTuple(0, 1, [2], 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, value, *values):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(1).extend((1,))
    iTuple(0, 1)
    &gt;&gt;&gt; iTuple.range(1).extend([1])
    iTuple(0, 1)
    &gt;&gt;&gt; iTuple.range(1).extend([1], [2])
    iTuple(0, 1, 2)
    &gt;&gt;&gt; iTuple.range(1).extend([1], [[2]])
    iTuple(0, 1, [2])
    &gt;&gt;&gt; iTuple.range(1).extend([1], [[2]], [2])
    iTuple(0, 1, [2], 2)
    &#34;&#34;&#34;
    return iTuple(data=itertools.chain.from_iterable(
        (self, value, *values)
    ))</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, f, eq=None, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).filter(lambda x: x &gt; 1)
iTuple(2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, f, eq = None, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).filter(lambda x: x &gt; 1)
    iTuple(2)
    &#34;&#34;&#34;
    # res = []
    # for v in self.iter():
    #     if f(v):
    #         res.append(v)
    return iTuple(data=(
        v for v in self.iter() if f(v)
    ))</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.filter_eq"><code class="name flex">
<span>def <span class="ident">filter_eq</span></span>(<span>self, v, f=None, eq=None, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).filter_eq(1)
iTuple(1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_eq(self, v, f = None, eq = None, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).filter_eq(1)
    iTuple(1)
    &#34;&#34;&#34;
    if f is None and eq is None:
        res = filter(lambda x: x == v, self)
    elif f is not None:
        res = filter(lambda x: f(x) == v, self)
    elif eq is not None:
        res = filter(lambda x: eq(x, v), self)
    else:
        res = filter(lambda x: eq(f(x), v), self)
    return res if lazy else type(self)(data=res)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.first"><code class="name flex">
<span>def <span class="ident">first</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).first()
0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).first()
    0
    &#34;&#34;&#34;
    return self[0]</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.first_where"><code class="name flex">
<span>def <span class="ident">first_where</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).first_where(lambda v: v &gt; 0)
1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_where(self, f):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).first_where(lambda v: v &gt; 0)
    1
    &#34;&#34;&#34;
    for v in self:
        if f(v):
            return v
    return None</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).map(lambda x: [x]).flatten()
iTuple(0, 1, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).map(lambda x: [x]).flatten()
    iTuple(0, 1, 2)
    &#34;&#34;&#34;
    return iTuple(data=itertools.chain(*self))</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self, f, initial=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v)
2
&gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v, initial=0)
2
&gt;&gt;&gt; iTuple.range(3).fold(operator.add)
3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self, f, initial=None):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v)
    2
    &gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v, initial=0)
    2
    &gt;&gt;&gt; iTuple.range(3).fold(operator.add)
    3
    &#34;&#34;&#34;
    # acc = initial
    # for v in self.iter():
    #     acc = f(acc, v)
    # return iTuple(data=tuple(acc))
    if initial is not None:
        return functools.reduce(f, self, initial)
    else:
        return functools.reduce(f, self)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.foldcum"><code class="name flex">
<span>def <span class="ident">foldcum</span></span>(<span>self, *args, initial=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).foldcum(lambda acc, v: v)
iTuple(0, 1, 2)
&gt;&gt;&gt; iTuple.range(3).foldcum(operator.add)
iTuple(0, 1, 3)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def foldcum(self, *args, initial=None, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).foldcum(lambda acc, v: v)
    iTuple(0, 1, 2)
    &gt;&gt;&gt; iTuple.range(3).foldcum(operator.add)
    iTuple(0, 1, 3)
    &#34;&#34;&#34;
    # res = []
    # acc = initial
    # for x in self.iter():
    #     acc = f(acc, x)
    #     res.append(acc)
    # return iTuple(data=tuple(res))
    return self.accumulate(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, i):
    return self.data[i]</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.groupby"><code class="name flex">
<span>def <span class="ident">groupby</span></span>(<span>self, f, lazy=False, keys=False, pipe=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).groupby(lambda x: x &lt; 2)
iTuple((0, 1), (2,))
&gt;&gt;&gt; iTuple.range(3).groupby(
...    lambda x: x &lt; 2, keys=True, pipe=fDict
... )
{True: (0, 1), False: (2,)}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groupby(
    self, 
    f, 
    lazy = False, 
    keys = False,
    pipe= None,
):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).groupby(lambda x: x &lt; 2)
    iTuple((0, 1), (2,))
    &gt;&gt;&gt; iTuple.range(3).groupby(
    ...    lambda x: x &lt; 2, keys=True, pipe=fDict
    ... )
    {True: (0, 1), False: (2,)}
    &#34;&#34;&#34;
    # TODO: lazy no keys
    res = itertools.groupby(self, key=f)
    if lazy and keys and pipe is None:
        return res
    if pipe is None:
        pipe = iTuple
    if keys:
        return pipe((k, tuple(g),) for k, g in res)
    else:
        return pipe(tuple(g) for k, g in res)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.islice"><code class="name flex">
<span>def <span class="ident">islice</span></span>(<span>self, left=None, right=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(5).islice(1, 3)
iTuple(1, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def islice(self, left = None, right = None):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(5).islice(1, 3)
    iTuple(1, 2)
    &#34;&#34;&#34;
    return self[left:right]</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.iter"><code class="name flex">
<span>def <span class="ident">iter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; for x in iTuple.range(3).iter(): print(x)
0
1
2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; for x in iTuple.range(3).iter(): print(x)
    0
    1
    2
    &#34;&#34;&#34;
    return iter(self.data)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).last()
2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).last()
    2
    &#34;&#34;&#34;
    return self[-1]</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.last_where"><code class="name flex">
<span>def <span class="ident">last_where</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).last_where(lambda v: v &lt; 2)
1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last_where(self, f):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).last_where(lambda v: v &lt; 2)
    1
    &#34;&#34;&#34;
    for v in reversed(self):
        if f(v):
            return v
    return None</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.len"><code class="name flex">
<span>def <span class="ident">len</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).len()
3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def len(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).len()
    3
    &#34;&#34;&#34;
    return len(self.data)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, f, *iterables, at=None, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).map(lambda x: x * 2)
iTuple(0, 2, 4)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, f, *iterables, at = None, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).map(lambda x: x * 2)
    iTuple(0, 2, 4)
    &#34;&#34;&#34;
    # if lazy and at is None:
    #     return map(f, self.data, *iterables)
    if at is None:
        return iTuple(data = map(f, self.data, *iterables))
    elif isinstance(at, int):
        return iTuple(data = map(
            f, *iterables[:at], self.data, *iterables[at:]
        ))
    else:
        assert False, at</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.mapstar"><code class="name flex">
<span>def <span class="ident">mapstar</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mapstar(self, f):
    return iTuple(data=itertools.starmap(f, self.data))</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.partial"><code class="name flex">
<span>def <span class="ident">partial</span></span>(<span>self, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; f = iTuple.range(2).partial(
...     lambda it, v: it.map(lambda x: x * v)
... )
&gt;&gt;&gt; f(2)
iTuple(0, 2)
&gt;&gt;&gt; f(3)
iTuple(0, 3)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partial(self, f, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; f = iTuple.range(2).partial(
    ...     lambda it, v: it.map(lambda x: x * v)
    ... )
    &gt;&gt;&gt; f(2)
    iTuple(0, 2)
    &gt;&gt;&gt; f(3)
    iTuple(0, 3)
    &#34;&#34;&#34;
    return functools.partial(f, self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, f, *args, at=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(2).pipe(lambda it: it)
iTuple(0, 1)
&gt;&gt;&gt; iTuple.range(2).pipe(
...     lambda it, v: it.map(lambda x: x * v), 2
... )
iTuple(0, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, f, *args, at = None, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(2).pipe(lambda it: it)
    iTuple(0, 1)
    &gt;&gt;&gt; iTuple.range(2).pipe(
    ...     lambda it, v: it.map(lambda x: x * v), 2
    ... )
    iTuple(0, 2)
    &#34;&#34;&#34;
    return pipe(f, self, *args, at = at, **kwargs)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.prepend"><code class="name flex">
<span>def <span class="ident">prepend</span></span>(<span>self, value, *values)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(1).prepend(1)
iTuple(1, 0)
&gt;&gt;&gt; iTuple.range(1).prepend(1, 2)
iTuple(1, 2, 0)
&gt;&gt;&gt; iTuple.range(1).prepend(1, 2, 3)
iTuple(1, 2, 3, 0)
&gt;&gt;&gt; iTuple.range(1).prepend(1, (2,))
iTuple(1, (2,), 0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepend(self, value, *values):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(1).prepend(1)
    iTuple(1, 0)
    &gt;&gt;&gt; iTuple.range(1).prepend(1, 2)
    iTuple(1, 2, 0)
    &gt;&gt;&gt; iTuple.range(1).prepend(1, 2, 3)
    iTuple(1, 2, 3, 0)
    &gt;&gt;&gt; iTuple.range(1).prepend(1, (2,))
    iTuple(1, (2,), 0)
    &#34;&#34;&#34;
    return iTuple(data=(value, *values, *self.data))</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.pretend"><code class="name flex">
<span>def <span class="ident">pretend</span></span>(<span>self, value, *values)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(1).pretend((1,))
iTuple(1, 0)
&gt;&gt;&gt; iTuple.range(1).pretend([1])
iTuple(1, 0)
&gt;&gt;&gt; iTuple.range(1).pretend([1], [2])
iTuple(1, 2, 0)
&gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]])
iTuple(1, [2], 0)
&gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]], [2])
iTuple(1, [2], 2, 0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretend(self, value, *values):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(1).pretend((1,))
    iTuple(1, 0)
    &gt;&gt;&gt; iTuple.range(1).pretend([1])
    iTuple(1, 0)
    &gt;&gt;&gt; iTuple.range(1).pretend([1], [2])
    iTuple(1, 2, 0)
    &gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]])
    iTuple(1, [2], 0)
    &gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]], [2])
    iTuple(1, [2], 2, 0)
    &#34;&#34;&#34;
    return iTuple(data=itertools.chain.from_iterable(
        (value, *values, self)
    ))</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).reverse()
iTuple(2, 1, 0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse(self, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).reverse()
    iTuple(2, 1, 0)
    &#34;&#34;&#34;
    if lazy:
        return reversed(self)
    return type(self)(data=reversed(self))</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, f=&lt;function iTuple.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).reverse().sort()
iTuple(0, 1, 2)
&gt;&gt;&gt; iTuple.range(3).sort()
iTuple(0, 1, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, f = lambda v: v):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).reverse().sort()
    iTuple(0, 1, 2)
    &gt;&gt;&gt; iTuple.range(3).sort()
    iTuple(0, 1, 2)
    &#34;&#34;&#34;
    return type(self)(data=sorted(self, key = f))</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).tail(2)
iTuple(1, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self, n):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).tail(2)
    iTuple(1, 2)
    &#34;&#34;&#34;
    return self[-n:]</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.tail_after"><code class="name flex">
<span>def <span class="ident">tail_after</span></span>(<span>self, f, n=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2)
iTuple(0, 1)
&gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2, 1)
iTuple(1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail_after(self, f, n = None):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2)
    iTuple(0, 1)
    &gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2, 1)
    iTuple(1)
    &#34;&#34;&#34;
    l = 0
    r = 0
    for v in reversed(self):
        if not f(v):
            l += 1
        elif n is None or r &lt; n:
            r += 1
        else:
            break
    return self.tail(l + r).take(r)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.tail_while"><code class="name flex">
<span>def <span class="ident">tail_while</span></span>(<span>self, f, n=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).tail_while(lambda v: v &gt; 1)
iTuple(2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail_while(self, f, n = None):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).tail_while(lambda v: v &gt; 1)
    iTuple(2)
    &#34;&#34;&#34;
    i = 0
    for v in reversed(self):
        if f(v) and (n is None or i &lt; n):
            i += 1
        else:
            break
    return self.tail(i)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).take(2)
iTuple(0, 1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take(self, n):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).take(2)
    iTuple(0, 1)
    &#34;&#34;&#34;
    return self[:n]</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.take_after"><code class="name flex">
<span>def <span class="ident">take_after</span></span>(<span>self, f, n=None, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1)
iTuple(1, 2)
&gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1, n = 1)
iTuple(1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_after(self, f, n = None, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1)
    iTuple(1, 2)
    &gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1, n = 1)
    iTuple(1)
    &#34;&#34;&#34;
    def iter():
        i = 0
        for v in self:
            if f(v):
                pass
            elif n is None or i &lt; n:
                yield v
                i += 1
            else:
                return
    res = iter()
    return res if lazy else type(self)(data=res)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.take_while"><code class="name flex">
<span>def <span class="ident">take_while</span></span>(<span>self, f, n=None, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).take_while(lambda v: v &lt; 1)
iTuple(0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_while(self, f, n = None, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).take_while(lambda v: v &lt; 1)
    iTuple(0)
    &#34;&#34;&#34;
    def iter():
        i = 0
        for v in self:
            if f(v) and (n is None or i &lt; n):
                yield v
                i += 1
            else:
                return
    res = iter()
    return res if lazy else type(self)(data=res)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.unique"><code class="name flex">
<span>def <span class="ident">unique</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple([1, 1, 3, 2, 4, 2, 3]).unique()
iTuple(1, 3, 2, 4)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unique(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple([1, 1, 3, 2, 4, 2, 3]).unique()
    iTuple(1, 3, 2, 4)
    &#34;&#34;&#34;
    def iter():
        seen = set()
        seen_add = seen.add
        seen_contains = seen.__contains__
        for v in itertools.filterfalse(seen_contains, self):
            seen_add(v)
            yield v
    return type(self)(data=iter())</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.iTuple.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self, *itrs, lazy=False, at=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple([[1, 1], [2, 2], [3, 3]]).zip()
iTuple((1, 2, 3), (1, 2, 3))
&gt;&gt;&gt; iTuple([iTuple.range(3), iTuple.range(1, 4)]).zip()
iTuple((0, 1), (1, 2), (2, 3))
&gt;&gt;&gt; iTuple.range(3).zip(iTuple.range(1, 4))
iTuple((0, 1), (1, 2), (2, 3))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self, *itrs, lazy = False, at = None):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple([[1, 1], [2, 2], [3, 3]]).zip()
    iTuple((1, 2, 3), (1, 2, 3))
    &gt;&gt;&gt; iTuple([iTuple.range(3), iTuple.range(1, 4)]).zip()
    iTuple((0, 1), (1, 2), (2, 3))
    &gt;&gt;&gt; iTuple.range(3).zip(iTuple.range(1, 4))
    iTuple((0, 1), (1, 2), (2, 3))
    &#34;&#34;&#34;
    if len(itrs) == 0:
        res = zip(*self)
    elif at is None:
        res = zip(self, *itrs)
    elif isinstance(at, int):
        res = zip(*itrs[:at], self, *itrs[at:])
    else:
        assert False, at
    return res if lazy else iTuple(data=res)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.xtuples.xtuples.nTuple"><code class="flex name class">
<span>class <span class="ident">nTuple</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nTuple(abc.ABC):

    @abc.abstractmethod
    def __abstract__(self):
        # NOTE: here to prevent initialise instances of this
        # but rather use the decorator and typing.NamedTuple
        return

    @staticmethod
    def pipe(obj, f, *args, at = None, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; example = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; example.pipe(lambda a, b: a, None)
        Example(x=1, s=&#39;a&#39;, it=iTuple())
        &gt;&gt;&gt; example.pipe(lambda a, b: a, None, at = 1)
        &gt;&gt;&gt; example.pipe(lambda a, b: a, None, at = &#39;b&#39;)
        &gt;&gt;&gt; example.pipe(lambda a, b: a, a=None, at = &#39;b&#39;)
        &gt;&gt;&gt; example.pipe(lambda a, b: a, b=None, at = &#39;a&#39;)
        Example(x=1, s=&#39;a&#39;, it=iTuple())
        &gt;&gt;&gt; example.pipe(lambda a, b: a, None, at = 0)
        Example(x=1, s=&#39;a&#39;, it=iTuple())
        &#34;&#34;&#34;
        return pipe(f, obj, *args, at = at, **kwargs)

    @staticmethod
    def partial(obj, f, *args, **kwargs):
        return functools.partial(f, obj, *args, **kwargs)

    @classmethod
    def is_subclass(cls, t):
        &#34;&#34;&#34;
        &gt;&gt;&gt; nTuple.is_subclass(tuple)
        False
        &gt;&gt;&gt; nTuple.is_subclass(Example(1, &#34;a&#34;))
        False
        &gt;&gt;&gt; nTuple.is_subclass(Example)
        True
        &#34;&#34;&#34;
        try:
            is_sub = issubclass(t, tuple)
        except:
            is_sub = False
        return (
            is_sub and
            hasattr(t, &#34;cls&#34;) and
            hasattr(t, &#34;pipe&#34;) and
            hasattr(t, &#34;partial&#34;)
        )

    @classmethod
    def is_instance(cls, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; nTuple.is_instance(tuple)
        False
        &gt;&gt;&gt; nTuple.is_instance(Example)
        False
        &gt;&gt;&gt; nTuple.is_instance(Example(1, &#34;a&#34;))
        True
        &#34;&#34;&#34;
        return (
            cls.is_subclass(type(obj)) and
            hasattr(obj, &#39;_asdict&#39;) and
            hasattr(obj, &#39;_fields&#39;)
        )


    @staticmethod
    def annotations(obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; ex.pipe(ex.cls.annotations)
        {&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;s&#39;: &lt;class &#39;str&#39;&gt;, &#39;it&#39;: &lt;class &#39;xtuples.xtuples.iTuple&#39;&gt;}
        &#34;&#34;&#34;
        return fDict(obj.__annotations__)

    @classmethod
    def as_dict(cls, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; ex.pipe(ex.cls.as_dict)
        {&#39;x&#39;: 1, &#39;s&#39;: &#39;a&#39;, &#39;it&#39;: iTuple()}
        &#34;&#34;&#34;
        return fDict(obj._asdict())

    @classmethod
    def decorate(meta, cls):
        if cls.__name__ in REGISTRY:
            print(&#34;NOTE, re-registering: {}&#34;.format(cls.__name__))
        cls.pipe = meta.pipe
        cls.partial = meta.partial
        cls.cls = meta
        REGISTRY[cls.__name__] = cls
        return cls

    @classmethod
    def replace(cls, *ks):
        def f(obj, *vs):
            return obj._replace(**{k: v for k, v in zip(ks, vs)})
        return f</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="src.xtuples.xtuples.nTuple.annotations"><code class="name flex">
<span>def <span class="ident">annotations</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; ex = Example(1, &quot;a&quot;)
&gt;&gt;&gt; ex.pipe(ex.cls.annotations)
{'x': &lt;class 'int'&gt;, 's': &lt;class 'str'&gt;, 'it': &lt;class 'xtuples.xtuples.iTuple'&gt;}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def annotations(obj):
    &#34;&#34;&#34;
    &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
    &gt;&gt;&gt; ex.pipe(ex.cls.annotations)
    {&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;s&#39;: &lt;class &#39;str&#39;&gt;, &#39;it&#39;: &lt;class &#39;xtuples.xtuples.iTuple&#39;&gt;}
    &#34;&#34;&#34;
    return fDict(obj.__annotations__)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.nTuple.as_dict"><code class="name flex">
<span>def <span class="ident">as_dict</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; ex = Example(1, &quot;a&quot;)
&gt;&gt;&gt; ex.pipe(ex.cls.as_dict)
{'x': 1, 's': 'a', 'it': iTuple()}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def as_dict(cls, obj):
    &#34;&#34;&#34;
    &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
    &gt;&gt;&gt; ex.pipe(ex.cls.as_dict)
    {&#39;x&#39;: 1, &#39;s&#39;: &#39;a&#39;, &#39;it&#39;: iTuple()}
    &#34;&#34;&#34;
    return fDict(obj._asdict())</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.nTuple.decorate"><code class="name flex">
<span>def <span class="ident">decorate</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def decorate(meta, cls):
    if cls.__name__ in REGISTRY:
        print(&#34;NOTE, re-registering: {}&#34;.format(cls.__name__))
    cls.pipe = meta.pipe
    cls.partial = meta.partial
    cls.cls = meta
    REGISTRY[cls.__name__] = cls
    return cls</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.nTuple.is_instance"><code class="name flex">
<span>def <span class="ident">is_instance</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; nTuple.is_instance(tuple)
False
&gt;&gt;&gt; nTuple.is_instance(Example)
False
&gt;&gt;&gt; nTuple.is_instance(Example(1, &quot;a&quot;))
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_instance(cls, obj):
    &#34;&#34;&#34;
    &gt;&gt;&gt; nTuple.is_instance(tuple)
    False
    &gt;&gt;&gt; nTuple.is_instance(Example)
    False
    &gt;&gt;&gt; nTuple.is_instance(Example(1, &#34;a&#34;))
    True
    &#34;&#34;&#34;
    return (
        cls.is_subclass(type(obj)) and
        hasattr(obj, &#39;_asdict&#39;) and
        hasattr(obj, &#39;_fields&#39;)
    )</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.nTuple.is_subclass"><code class="name flex">
<span>def <span class="ident">is_subclass</span></span>(<span>t)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; nTuple.is_subclass(tuple)
False
&gt;&gt;&gt; nTuple.is_subclass(Example(1, &quot;a&quot;))
False
&gt;&gt;&gt; nTuple.is_subclass(Example)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_subclass(cls, t):
    &#34;&#34;&#34;
    &gt;&gt;&gt; nTuple.is_subclass(tuple)
    False
    &gt;&gt;&gt; nTuple.is_subclass(Example(1, &#34;a&#34;))
    False
    &gt;&gt;&gt; nTuple.is_subclass(Example)
    True
    &#34;&#34;&#34;
    try:
        is_sub = issubclass(t, tuple)
    except:
        is_sub = False
    return (
        is_sub and
        hasattr(t, &#34;cls&#34;) and
        hasattr(t, &#34;pipe&#34;) and
        hasattr(t, &#34;partial&#34;)
    )</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.nTuple.partial"><code class="name flex">
<span>def <span class="ident">partial</span></span>(<span>obj, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def partial(obj, f, *args, **kwargs):
    return functools.partial(f, obj, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.nTuple.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>obj, f, *args, at=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; example = Example(1, &quot;a&quot;)
&gt;&gt;&gt; example.pipe(lambda a, b: a, None)
Example(x=1, s='a', it=iTuple())
&gt;&gt;&gt; example.pipe(lambda a, b: a, None, at = 1)
&gt;&gt;&gt; example.pipe(lambda a, b: a, None, at = 'b')
&gt;&gt;&gt; example.pipe(lambda a, b: a, a=None, at = 'b')
&gt;&gt;&gt; example.pipe(lambda a, b: a, b=None, at = 'a')
Example(x=1, s='a', it=iTuple())
&gt;&gt;&gt; example.pipe(lambda a, b: a, None, at = 0)
Example(x=1, s='a', it=iTuple())
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pipe(obj, f, *args, at = None, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; example = Example(1, &#34;a&#34;)
    &gt;&gt;&gt; example.pipe(lambda a, b: a, None)
    Example(x=1, s=&#39;a&#39;, it=iTuple())
    &gt;&gt;&gt; example.pipe(lambda a, b: a, None, at = 1)
    &gt;&gt;&gt; example.pipe(lambda a, b: a, None, at = &#39;b&#39;)
    &gt;&gt;&gt; example.pipe(lambda a, b: a, a=None, at = &#39;b&#39;)
    &gt;&gt;&gt; example.pipe(lambda a, b: a, b=None, at = &#39;a&#39;)
    Example(x=1, s=&#39;a&#39;, it=iTuple())
    &gt;&gt;&gt; example.pipe(lambda a, b: a, None, at = 0)
    Example(x=1, s=&#39;a&#39;, it=iTuple())
    &#34;&#34;&#34;
    return pipe(f, obj, *args, at = at, **kwargs)</code></pre>
</details>
</dd>
<dt id="src.xtuples.xtuples.nTuple.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>*ks)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def replace(cls, *ks):
    def f(obj, *vs):
        return obj._replace(**{k: v for k, v in zip(ks, vs)})
    return f</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.xtuples" href="index.html">src.xtuples</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.xtuples.xtuples.fDict" href="#src.xtuples.xtuples.fDict">fDict</a></code></h4>
<ul class="two-column">
<li><code><a title="src.xtuples.xtuples.fDict.data" href="#src.xtuples.xtuples.fDict.data">data</a></code></li>
<li><code><a title="src.xtuples.xtuples.fDict.invert" href="#src.xtuples.xtuples.fDict.invert">invert</a></code></li>
<li><code><a title="src.xtuples.xtuples.fDict.items_tuple" href="#src.xtuples.xtuples.fDict.items_tuple">items_tuple</a></code></li>
<li><code><a title="src.xtuples.xtuples.fDict.keys_tuple" href="#src.xtuples.xtuples.fDict.keys_tuple">keys_tuple</a></code></li>
<li><code><a title="src.xtuples.xtuples.fDict.map_items" href="#src.xtuples.xtuples.fDict.map_items">map_items</a></code></li>
<li><code><a title="src.xtuples.xtuples.fDict.map_keys" href="#src.xtuples.xtuples.fDict.map_keys">map_keys</a></code></li>
<li><code><a title="src.xtuples.xtuples.fDict.map_values" href="#src.xtuples.xtuples.fDict.map_values">map_values</a></code></li>
<li><code><a title="src.xtuples.xtuples.fDict.partial" href="#src.xtuples.xtuples.fDict.partial">partial</a></code></li>
<li><code><a title="src.xtuples.xtuples.fDict.pipe" href="#src.xtuples.xtuples.fDict.pipe">pipe</a></code></li>
<li><code><a title="src.xtuples.xtuples.fDict.values_tuple" href="#src.xtuples.xtuples.fDict.values_tuple">values_tuple</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.xtuples.xtuples.iTuple" href="#src.xtuples.xtuples.iTuple">iTuple</a></code></h4>
<ul class="two-column">
<li><code><a title="src.xtuples.xtuples.iTuple.accumulate" href="#src.xtuples.xtuples.iTuple.accumulate">accumulate</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.append" href="#src.xtuples.xtuples.iTuple.append">append</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.data" href="#src.xtuples.xtuples.iTuple.data">data</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.decorate" href="#src.xtuples.xtuples.iTuple.decorate">decorate</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.enumerate" href="#src.xtuples.xtuples.iTuple.enumerate">enumerate</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.extend" href="#src.xtuples.xtuples.iTuple.extend">extend</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.filter" href="#src.xtuples.xtuples.iTuple.filter">filter</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.filter_eq" href="#src.xtuples.xtuples.iTuple.filter_eq">filter_eq</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.first" href="#src.xtuples.xtuples.iTuple.first">first</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.first_where" href="#src.xtuples.xtuples.iTuple.first_where">first_where</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.flatten" href="#src.xtuples.xtuples.iTuple.flatten">flatten</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.fold" href="#src.xtuples.xtuples.iTuple.fold">fold</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.foldcum" href="#src.xtuples.xtuples.iTuple.foldcum">foldcum</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.from_items" href="#src.xtuples.xtuples.iTuple.from_items">from_items</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.from_keys" href="#src.xtuples.xtuples.iTuple.from_keys">from_keys</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.from_values" href="#src.xtuples.xtuples.iTuple.from_values">from_values</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.get" href="#src.xtuples.xtuples.iTuple.get">get</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.groupby" href="#src.xtuples.xtuples.iTuple.groupby">groupby</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.islice" href="#src.xtuples.xtuples.iTuple.islice">islice</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.iter" href="#src.xtuples.xtuples.iTuple.iter">iter</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.last" href="#src.xtuples.xtuples.iTuple.last">last</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.last_where" href="#src.xtuples.xtuples.iTuple.last_where">last_where</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.len" href="#src.xtuples.xtuples.iTuple.len">len</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.map" href="#src.xtuples.xtuples.iTuple.map">map</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.mapstar" href="#src.xtuples.xtuples.iTuple.mapstar">mapstar</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.partial" href="#src.xtuples.xtuples.iTuple.partial">partial</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.pipe" href="#src.xtuples.xtuples.iTuple.pipe">pipe</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.prepend" href="#src.xtuples.xtuples.iTuple.prepend">prepend</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.pretend" href="#src.xtuples.xtuples.iTuple.pretend">pretend</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.range" href="#src.xtuples.xtuples.iTuple.range">range</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.reverse" href="#src.xtuples.xtuples.iTuple.reverse">reverse</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.sort" href="#src.xtuples.xtuples.iTuple.sort">sort</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.tail" href="#src.xtuples.xtuples.iTuple.tail">tail</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.tail_after" href="#src.xtuples.xtuples.iTuple.tail_after">tail_after</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.tail_while" href="#src.xtuples.xtuples.iTuple.tail_while">tail_while</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.take" href="#src.xtuples.xtuples.iTuple.take">take</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.take_after" href="#src.xtuples.xtuples.iTuple.take_after">take_after</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.take_while" href="#src.xtuples.xtuples.iTuple.take_while">take_while</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.unique" href="#src.xtuples.xtuples.iTuple.unique">unique</a></code></li>
<li><code><a title="src.xtuples.xtuples.iTuple.zip" href="#src.xtuples.xtuples.iTuple.zip">zip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.xtuples.xtuples.nTuple" href="#src.xtuples.xtuples.nTuple">nTuple</a></code></h4>
<ul class="two-column">
<li><code><a title="src.xtuples.xtuples.nTuple.annotations" href="#src.xtuples.xtuples.nTuple.annotations">annotations</a></code></li>
<li><code><a title="src.xtuples.xtuples.nTuple.as_dict" href="#src.xtuples.xtuples.nTuple.as_dict">as_dict</a></code></li>
<li><code><a title="src.xtuples.xtuples.nTuple.decorate" href="#src.xtuples.xtuples.nTuple.decorate">decorate</a></code></li>
<li><code><a title="src.xtuples.xtuples.nTuple.is_instance" href="#src.xtuples.xtuples.nTuple.is_instance">is_instance</a></code></li>
<li><code><a title="src.xtuples.xtuples.nTuple.is_subclass" href="#src.xtuples.xtuples.nTuple.is_subclass">is_subclass</a></code></li>
<li><code><a title="src.xtuples.xtuples.nTuple.partial" href="#src.xtuples.xtuples.nTuple.partial">partial</a></code></li>
<li><code><a title="src.xtuples.xtuples.nTuple.pipe" href="#src.xtuples.xtuples.nTuple.pipe">pipe</a></code></li>
<li><code><a title="src.xtuples.xtuples.nTuple.replace" href="#src.xtuples.xtuples.nTuple.replace">replace</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>