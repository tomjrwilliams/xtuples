<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xtuples API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xtuples</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ---------------------------------------------------------------

import json

import abc
import typing
import dataclasses
import collections

import operator
import itertools
import functools

# ---------------------------------------------------------------

# NOTE: at worst, not worse, than an un-optimised canonical solution

# where I cribbed from the itertools recipes (and other python docs), all credit to the original authors.

# where i didn&#39;t, i probably should have.

# ---------------------------------------------------------------

REGISTRY = {}

# ---------------------------------------------------------------

# TODO: context manager to control
# if we add the type information when writing to json or not

# TODO: context mananger to control
# lazy default behaviour (ie. default to lazy or not)

# ---------------------------------------------------------------

class JSONEncoder(json.JSONEncoder):

    def iterencode(self, o, *args, **kwargs):
        for chunk in super().iterencode(
            cast_json(o), *args, **kwargs
        ):
            yield chunk

    # def meta_default(self, obj):
    #     return json.JSONEncoder.default(self, obj)

    # def default(self, obj):
    #     if isinstance(obj, fDict):
    #         return self.meta_default(obj.data)
    #     return cast_json(obj, default=self.meta_default)

# -----

class JSONDecoder(json.JSONDecoder):

    def __init__(self, *args, **kwargs):
        json.JSONDecoder.__init__(
            self,
            object_hook=self.object_hook,
            *args,
            **kwargs
            #
        )

    @classmethod
    def xtuple_object_hook(cls, d):
        return uncast_json(d)

    def object_hook(self, d):
        return self.xtuple_object_hook(d)

# -----

def cast_json(obj, default = lambda obj: obj):
    if nTuple.is_instance(obj):
        return nTuple.cast_json(obj)
    try:
        return obj.cast_json()
    except:
        return default(obj)

def uncast_json(obj):
    if not isinstance(obj, dict):
        return obj
    __t__ = obj.get(&#34;__t__&#34;, None)
    if __t__ is None:
        return obj
    cls = iTuple if __t__ == &#34;iTuple&#34; else REGISTRY[__t__]
    if hasattr(cls, &#34;uncast_json&#34;):
        return cls.uncast_json(obj)
    return cls(
        *(v for k, v in obj.items() if k != &#34;__t__&#34;)
    )

# -----

# TODO: fString so can do .pipe ?
def to_json(v, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; print(iTuple([Example(1, &#34;a&#34;)]).pipe(to_json, indent=2))
    {
      &#34;__t__&#34;: &#34;iTuple&#34;,
      &#34;data&#34;: [
        {
          &#34;x&#34;: 1,
          &#34;s&#34;: &#34;a&#34;,
          &#34;it&#34;: {
            &#34;__t__&#34;: &#34;iTuple&#34;,
            &#34;data&#34;: []
          },
          &#34;__t__&#34;: &#34;Example&#34;
        }
      ]
    }
    &gt;&gt;&gt; print(iTuple([
    ...     iTuple([Example(1, &#34;a&#34;)])
    ... ]).pipe(to_json, indent=2))
    {
      &#34;__t__&#34;: &#34;iTuple&#34;,
      &#34;data&#34;: [
        {
          &#34;__t__&#34;: &#34;iTuple&#34;,
          &#34;data&#34;: [
            {
              &#34;x&#34;: 1,
              &#34;s&#34;: &#34;a&#34;,
              &#34;it&#34;: {
                &#34;__t__&#34;: &#34;iTuple&#34;,
                &#34;data&#34;: []
              },
              &#34;__t__&#34;: &#34;Example&#34;
            }
          ]
        }
      ]
    }
    &gt;&gt;&gt; print(Example(2, &#34;b&#34;, iTuple([
    ...     iTuple([Example(1, &#34;a&#34;)])
    ... ])).pipe(to_json, indent=2))
    {
      &#34;x&#34;: 2,
      &#34;s&#34;: &#34;b&#34;,
      &#34;it&#34;: {
        &#34;__t__&#34;: &#34;iTuple&#34;,
        &#34;data&#34;: [
          {
            &#34;__t__&#34;: &#34;iTuple&#34;,
            &#34;data&#34;: [
              {
                &#34;x&#34;: 1,
                &#34;s&#34;: &#34;a&#34;,
                &#34;it&#34;: {
                  &#34;__t__&#34;: &#34;iTuple&#34;,
                  &#34;data&#34;: []
                },
                &#34;__t__&#34;: &#34;Example&#34;
              }
            ]
          }
        ]
      },
      &#34;__t__&#34;: &#34;Example&#34;
    }
    &#34;&#34;&#34;
    return json.dumps(v, cls=JSONEncoder, **kwargs)

def from_json(v: str, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; ex = iTuple([Example(1, &#34;a&#34;)])
    &gt;&gt;&gt; from_json(ex.pipe(to_json))
    iTuple(Example(x=1, s=&#39;a&#39;, it=iTuple()))
    &gt;&gt;&gt; from_json(
    ...     iTuple([iTuple([Example(1, &#34;a&#34;)])]).pipe(to_json)
    ... )
    iTuple(iTuple(Example(x=1, s=&#39;a&#39;, it=iTuple())))
    &gt;&gt;&gt; from_json(
    ...     Example(2, &#34;b&#34;, iTuple([
    ...         iTuple([Example(1, &#34;a&#34;)])
    ...     ])).pipe(to_json)
    ... )
    Example(x=2, s=&#39;b&#39;, it=iTuple(iTuple(Example(x=1, s=&#39;a&#39;, it=iTuple()))))
    &#34;&#34;&#34;
    return json.loads(v, cls=JSONDecoder, **kwargs)

def load_json(f):
    return json.load(f, cls=JSONDecoder)

def dump_json(f, v):
    return json.dump(f, v, cls=JSONEncoder)

# ---------------------------------------------------------------

# TODO: some kind of validation placeholder?
# called in init, eg. quarter in [1 .. 4]

class nTuple(abc.ABC):

    @abc.abstractmethod
    def __abstract__(self):
        # NOTE: here to prevent initialise instances of this
        # but rather use the decorator and typing.NamedTuple
        return

    @staticmethod
    def pipe(obj, f, *args, **kwargs):
        return f(obj, *args, **kwargs)

    @staticmethod
    def partial(obj, f, *args, **kwargs):
        return functools.partial(f, obj, *args, **kwargs)

    @classmethod
    def is_subclass(cls, t):
        &#34;&#34;&#34;
        &gt;&gt;&gt; nTuple.is_subclass(tuple)
        False
        &gt;&gt;&gt; nTuple.is_subclass(Example(1, &#34;a&#34;))
        False
        &gt;&gt;&gt; nTuple.is_subclass(Example)
        True
        &#34;&#34;&#34;
        try:
            is_sub = issubclass(t, tuple)
        except:
            is_sub = False
        return (
            is_sub and
            hasattr(t, &#34;cls&#34;) and
            hasattr(t, &#34;pipe&#34;) and
            hasattr(t, &#34;partial&#34;)
        )

    @classmethod
    def is_instance(cls, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; nTuple.is_instance(tuple)
        False
        &gt;&gt;&gt; nTuple.is_instance(Example)
        False
        &gt;&gt;&gt; nTuple.is_instance(Example(1, &#34;a&#34;))
        True
        &#34;&#34;&#34;
        return (
            cls.is_subclass(type(obj)) and
            hasattr(obj, &#39;_asdict&#39;) and
            hasattr(obj, &#39;_fields&#39;)
        )


    @staticmethod
    def annotations(obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; ex.pipe(ex.cls.annotations)
        {&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;s&#39;: &lt;class &#39;str&#39;&gt;, &#39;it&#39;: &lt;class &#39;xtuples.xtuples.iTuple&#39;&gt;}
        &#34;&#34;&#34;
        return fDict(obj.__annotations__)

    @classmethod
    def as_dict(cls, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; ex.pipe(ex.cls.as_dict)
        {&#39;x&#39;: 1, &#39;s&#39;: &#39;a&#39;, &#39;it&#39;: iTuple()}
        &#34;&#34;&#34;
        return fDict(obj._asdict())

    @classmethod
    def cast_json(cls, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; ex.pipe(ex.cls.cast_json)
        {&#39;x&#39;: 1, &#39;s&#39;: &#39;a&#39;, &#39;it&#39;: {&#39;__t__&#39;: &#39;iTuple&#39;, &#39;data&#39;: []}, &#39;__t__&#39;: &#39;Example&#39;}
        &#34;&#34;&#34;
        d = {
            k: cast_json(v)
            for k, v in obj._asdict().items()
            #
        }
        d[&#34;__t__&#34;] = type(obj).__name__
        return d

    @classmethod
    def uncast_json(meta, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; ex.cls.uncast_json(ex.pipe(ex.cls.cast_json))
        Example(x=1, s=&#39;a&#39;, it=iTuple())
        &#34;&#34;&#34;
        cls = REGISTRY[obj[&#34;__t__&#34;]]
        return cls(
            *(
                uncast_json(v)
                for k, v in obj.items() if k != &#34;__t__&#34;
            )
        )

    @classmethod
    def decorate(meta, cls):
        assert cls.__name__ not in REGISTRY
        cls.pipe = meta.pipe
        cls.partial = meta.partial
        cls.cls = meta
        REGISTRY[cls.__name__] = cls
        return cls

# ---------------------------------------------------------------

class fDict(collections.UserDict):
    __slots__ = ()

    data: dict

    def pipe(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).pipe(lambda d: d.map_values(
        ...     lambda v: v + 1
        ... ))
        {0: 2}
        &#34;&#34;&#34;
        res = f(self, *args, **kwargs)
        if isinstance(res, dict):
            return fDict(res)
        return res

    def partial(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; f = fDict({0: 1}).partial(
        ...     lambda d, n: d.map_values(lambda v: v + n)
        ... )
        &gt;&gt;&gt; f(1)
        {0: 2}
        &gt;&gt;&gt; f(2)
        {0: 3}
        &#34;&#34;&#34;
        return functools.partial(f, self, *args, **kwargs)

    def keys_tuple(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).keys_tuple()
        iTuple(0)
        &#34;&#34;&#34;
        return iTuple.from_keys(self)

    def values_tuple(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).values_tuple()
        iTuple(1)
        &#34;&#34;&#34;
        return iTuple.from_values(self)
    
    def items_tuple(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).items_tuple()
        iTuple((0, 1))
        &#34;&#34;&#34;
        return iTuple.from_items(self)

    # NOTE: we have separate map implementations 
    # as they are constant size, dict to dict
    # other iterator functions should use iTuple (from the above)

    def map_keys(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).map_keys(lambda v: v + 1)
        {1: 1}
        &#34;&#34;&#34;
        return fDict(
            (f(k, *args, **kwargs), v) for k, v in self.items()
        )

    def map_values(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).map_values(lambda v: v + 1)
        {0: 2}
        &#34;&#34;&#34;
        return fDict(
            (k, f(v, *args, **kwargs)) for k, v in self.items()
        )

    def map_items(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).map_items(lambda k, v: (v, k))
        {1: 0}
        &#34;&#34;&#34;
        return fDict(
            f(k, v, *args, **kwargs) for k, v in self.items()
        )

    def invert(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).invert()
        {1: 0}
        &#34;&#34;&#34;
        return fDict((v, k) for k, v in self.items())

# ---------------------------------------------------------------

@dataclasses.dataclass(init = False, repr=True)
class iTuple(collections.UserList, tuple): # type: ignore
    __slots__ = ()

    data: tuple # type: ignore

    # -----

    @staticmethod
    def __new__(cls, data = None):
        # NOTE: we use cls not array
        # so sub-classing *does* change identity
        if isinstance(data, cls):
            return data
        return super().__new__(cls, data=data)

    @staticmethod
    def wrap_tuple(data):
        return data if isinstance(data, tuple) else tuple(data)
    
    def __init__(self, data = None):
        # TODO: option for lazy init?
        self.data = (
            tuple() if data is None
            else self.wrap_tuple(data)
        )

    def __repr__(self):
        s = super().__repr__()
        return &#34;{}({})&#34;.format(
            type(self).__name__,
            s[1:-2 if s[-2] == &#34;,&#34; else -1],
        )

    def __hash__(self):
        return hash(self.data)

    @classmethod
    def decorate(meta, cls):
        assert cls.__name__ not in REGISTRY
        REGISTRY[cls.__name__] = cls
        return cls

    # -----

    def cast_json(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).cast_json()
        {&#39;__t__&#39;: &#39;iTuple&#39;, &#39;data&#39;: [0]}
        &#34;&#34;&#34;
        return dict(
            __t__ = type(self).__name__,
            data = list(self.map(cast_json)),
        )

    @classmethod
    def uncast_json(cls, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.uncast_json(iTuple.range(1).cast_json())
        iTuple(0)
        &#34;&#34;&#34;
        assert obj[&#34;__t__&#34;] == cls.__name__
        return cls(data=obj[&#34;data&#34;])

    # -----

    @classmethod
    def range(cls, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3)
        iTuple(0, 1, 2)
        &#34;&#34;&#34;
        return cls(range(*args, **kwargs))

    @classmethod
    def from_keys(cls, d):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.from_keys({i: i + 1 for i in range(2)})
        iTuple(0, 1)
        &#34;&#34;&#34;
        return cls(d.keys())
        
    @classmethod
    def from_values(cls, d):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.from_values({i: i + 1 for i in range(2)})
        iTuple(1, 2)
        &#34;&#34;&#34;
        return cls(d.values())
        
    @classmethod
    def from_items(cls, d):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.from_items({i: i + 1 for i in range(2)})
        iTuple((0, 1), (1, 2))
        &#34;&#34;&#34;
        return cls(d.items())

    # -----

    def pipe(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(2).pipe(lambda it: it)
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(2).pipe(
        ...     lambda it, v: it.map(lambda x: x * v), 2
        ... )
        iTuple(0, 2)
        &#34;&#34;&#34;
        return f(self, *args, **kwargs)

    def partial(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; f = iTuple.range(2).partial(
        ...     lambda it, v: it.map(lambda x: x * v)
        ... )
        &gt;&gt;&gt; f(2)
        iTuple(0, 2)
        &gt;&gt;&gt; f(3)
        iTuple(0, 3)
        &#34;&#34;&#34;
        return functools.partial(f, self, *args, **kwargs)

    # -----

    def len(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).len()
        3
        &#34;&#34;&#34;
        return len(self)

    def append(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).append(1)
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(1).append(1, 2)
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(1).append(1, 2, 3)
        iTuple(0, 1, 2, 3)
        &gt;&gt;&gt; iTuple.range(1).append(1, (2,))
        iTuple(0, 1, (2,))
        &#34;&#34;&#34;
        return self + (value, *values)

    def prepend(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).prepend(1)
        iTuple(1, 0)
        &gt;&gt;&gt; iTuple.range(1).prepend(1, 2)
        iTuple(1, 2, 0)
        &gt;&gt;&gt; iTuple.range(1).prepend(1, 2, 3)
        iTuple(1, 2, 3, 0)
        &gt;&gt;&gt; iTuple.range(1).prepend(1, (2,))
        iTuple(1, (2,), 0)
        &#34;&#34;&#34;
        return (value, *values) + self

    def zip(self, *itrs, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple([[1, 1], [2, 2], [3, 3]]).zip()
        iTuple((1, 2, 3), (1, 2, 3))
        &gt;&gt;&gt; iTuple([iTuple.range(3), iTuple.range(1, 4)]).zip()
        iTuple((0, 1), (1, 2), (2, 3))
        &gt;&gt;&gt; iTuple.range(3).zip(iTuple.range(1, 4))
        iTuple((0, 1), (1, 2), (2, 3))
        &#34;&#34;&#34;
        if len(itrs) == 0:
            res = zip(*self)
        else:
            res = zip(self, *itrs)
        return res if lazy else iTuple(data=res)

    def flatten(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).map(lambda x: [x]).flatten()
        iTuple(0, 1, 2)
        &#34;&#34;&#34;
        return iTuple(itertools.chain(*self))

    def extend(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).extend((1,))
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(1).extend([1])
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(1).extend([1], [2])
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(1).extend([1], [[2]])
        iTuple(0, 1, [2])
        &gt;&gt;&gt; iTuple.range(1).extend([1], [[2]], [2])
        iTuple(0, 1, [2], 2)
        &#34;&#34;&#34;
        return iTuple(itertools.chain.from_iterable(
            (self, value, *values)
        ))

    def pretend(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).pretend((1,))
        iTuple(1, 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1])
        iTuple(1, 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1], [2])
        iTuple(1, 2, 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]])
        iTuple(1, [2], 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]], [2])
        iTuple(1, [2], 2, 0)
        &#34;&#34;&#34;
        return iTuple(itertools.chain.from_iterable(
            (value, *values, self)
        ))

    def filter_eq(self, v, f = None, eq = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).filter_eq(1)
        iTuple(1)
        &#34;&#34;&#34;
        if f is None and eq is None:
            res = filter(lambda x: x == v, self)
        elif f is not None:
            res = filter(lambda x: f(x) == v, self)
        elif eq is not None:
            res = filter(lambda x: eq(x, v), self)
        else:
            res = filter(lambda x: eq(f(x), v), self)
        return res if lazy else type(self)(data=res)

    def filter(self, f, eq = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).filter(lambda x: x &gt; 1)
        iTuple(2)
        &#34;&#34;&#34;
        return self.filter_eq(True, f = f, eq = eq, lazy = lazy)

    def map(self, f, *iterables, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).map(lambda x: x * 2)
        iTuple(0, 2, 4)
        &#34;&#34;&#34;
        res = map(f, self, *iterables)
        return res if lazy else iTuple(data=res)

    def enumerate(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).enumerate()
        iTuple((0, 0), (1, 1), (2, 2))
        &#34;&#34;&#34;
        # TODO: allow lazy
        return iTuple(enumerate(self))

    def groupby(
        self, 
        f, 
        lazy = False, 
        keys = False,
        pipe= None,
    ):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).groupby(lambda x: x &lt; 2)
        iTuple((0, 1), (2,))
        &gt;&gt;&gt; iTuple.range(3).groupby(
        ...    lambda x: x &lt; 2, keys=True, pipe=fDict
        ... )
        {True: (0, 1), False: (2,)}
        &#34;&#34;&#34;
        # TODO: lazy no keys
        res = itertools.groupby(self, key=f)
        if lazy and keys and pipe is None:
            return res
        if pipe is None:
            pipe = iTuple
        if keys:
            return pipe((k, tuple(g),) for k, g in res)
        else:
            return pipe(tuple(g) for k, g in res)

    def first(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).first()
        0
        &#34;&#34;&#34;
        return self[0]
    
    def last(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).last()
        2
        &#34;&#34;&#34;
        return self[-1]

    def first_where(self, f):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).first_where(lambda v: v &gt; 0)
        1
        &#34;&#34;&#34;
        for v in self:
            if f(v):
                return v
        return None

    def last_where(self, f):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).last_where(lambda v: v &lt; 2)
        1
        &#34;&#34;&#34;
        for v in reversed(self):
            if f(v):
                return v
        return None

    def take(self, n):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).take(2)
        iTuple(0, 1)
        &#34;&#34;&#34;
        return self[:n]

    def tail(self, n):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).tail(2)
        iTuple(1, 2)
        &#34;&#34;&#34;
        return self[-n:]

    def reverse(self, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).reverse()
        iTuple(2, 1, 0)
        &#34;&#34;&#34;
        if lazy:
            return reversed(self)
        return type(self)(data=reversed(self))

    def take_while(self, f, n = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).take_while(lambda v: v &lt; 1)
        iTuple(0)
        &#34;&#34;&#34;
        def iter():
            i = 0
            for v in self:
                if f(v) and (n is None or i &lt; n):
                    yield v
                    i += 1
                else:
                    return
        res = iter()
        return res if lazy else type(self)(data=res)

    def tail_while(self, f, n = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).tail_while(lambda v: v &gt; 1)
        iTuple(2)
        &#34;&#34;&#34;
        i = 0
        for v in reversed(self):
            if f(v) and (n is None or i &lt; n):
                i += 1
            else:
                break
        return self.tail(i)

    # NOTE: from as in, starting from first true
    # versus above, which is until first false
    def take_after(self, f, n = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1)
        iTuple(1, 2)
        &gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1, n = 1)
        iTuple(1)
        &#34;&#34;&#34;
        def iter():
            i = 0
            for v in self:
                if f(v):
                    pass
                elif n is None or i &lt; n:
                    yield v
                    i += 1
                else:
                    return
        res = iter()
        return res if lazy else type(self)(data=res)

    def tail_after(self, f, n = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2)
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2, 1)
        iTuple(1)
        &#34;&#34;&#34;
        l = 0
        r = 0
        for v in reversed(self):
            if not f(v):
                l += 1
            elif n is None or r &lt; n:
                r += 1
            else:
                break
        return self.tail(l + r).take(r)

    def islice(self, left = None, right = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(5).islice(1, 3)
        iTuple(1, 2)
        &#34;&#34;&#34;
        return self[left:right]

    def unique(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple([1, 1, 3, 2, 4, 2, 3]).unique()
        iTuple(1, 3, 2, 4)
        &#34;&#34;&#34;
        def iter():
            seen = set()
            seen_add = seen.add
            seen_contains = seen.__contains__
            for v in itertools.filterfalse(seen_contains, self):
                seen_add(v)
                yield v
        return type(self)(data=iter())
    
    def sort(self, f = lambda v: v):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).reverse().sort()
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).sort()
        iTuple(0, 1, 2)
        &#34;&#34;&#34;
        return type(self)(data=sorted(self, key = f))

    def accumulate(self, f, initial = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v)
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v, initial=0)
        iTuple(0, 0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).accumulate(operator.add)
        iTuple(0, 1, 3)
        &#34;&#34;&#34;
        res = itertools.accumulate(self, func=f, initial=initial)
        return res if lazy else iTuple(data=res)

    def foldcum(self, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).foldcum(lambda acc, v: v)
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).foldcum(operator.add)
        iTuple(0, 1, 3)
        &#34;&#34;&#34;
        return self.accumulate(*args, **kwargs)

    def fold(self, f, initial=None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v)
        2
        &gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v, initial=0)
        2
        &gt;&gt;&gt; iTuple.range(3).fold(operator.add)
        3
        &#34;&#34;&#34;
        if initial is not None:
            res = functools.reduce(f, self, initial)
        else:
            res = functools.reduce(f, self)
        return res

    # -----

    # combinatorics

    # -----

# ---------------------------------------------------------------

@nTuple.decorate
class Example(typing.NamedTuple):
    &#34;&#34;&#34;
    &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
    &gt;&gt;&gt; ex
    Example(x=1, s=&#39;a&#39;, it=iTuple())
    &gt;&gt;&gt; ex.cls
    &lt;class &#39;xtuples.xtuples.nTuple&#39;&gt;
    &gt;&gt;&gt; ex.pipe(lambda nt: nt.x)
    1
    &gt;&gt;&gt; f = ex.partial(lambda nt, v: nt.x * v)
    &gt;&gt;&gt; f(2)
    2
    &gt;&gt;&gt; f(3)
    3
    &#34;&#34;&#34;
    # NOTE: cls, pipe, partial are mandatory boilerplate

    x: int
    s: str
    it: iTuple = iTuple([])

    @property
    def cls(self):
        ...

    def pipe(self, f, *args, **kwargs):
        ...

    def partial(self, f, *args, **kwargs):
        ...

# ---------------------------------------------------------------

# import misc.perfmon

# def int_memory_gen(cum=False):
#     i = 0
#     while True:
#         yield i
#     return

# def dict_memory_gen(cum=False):
#     i = 0
#     if cum:
#         while True:
#             yield {ii: ii for ii in range(i)}
#             i += 1
#     else:
#         while True:
#             yield {i: i}
#             i += 1
#     return

# def list_memory_gen(cum=False):
#     i = 0
#     if cum:
#         while True:
#             yield list(range(i))
#             i += 1
#     else:
#         while True:
#             yield [i]
#             i += 1
#     return

# def iTuple_memory_gen(cum=False):
#     i = 0
#     if cum:
#         while True:
#             yield iTuple(range(i))
#             i += 1
#     else:
#         while True:
#             yield iTuple([i])
#             i += 1
#     return

# print(&#34;int&#34;, misc.perfmon.profile_memory(
#     int_memory_gen
# ))

# print(&#34;list&#34;, misc.perfmon.profile_memory(
#     list_memory_gen
# ))

# print(&#34;iTuple&#34;, misc.perfmon.profile_memory(
#     iTuple_memory_gen
# ))

# print(&#34;list cum&#34;, misc.perfmon.profile_memory(
#     list_memory_gen, cum=True,
# ))

# print(&#34;iTuple cum&#34;, misc.perfmon.profile_memory(
#     iTuple_memory_gen, cum=True,
# ))

# ---------------------------------------------------------------

# s = S(1)
# s_parent = S_Parent(s)

# print(s.cls.annotations(s))

# print(s.cls)

# print(s_parent.cast_json())

# print(iTuple([s_parent]).cast_json())

# # ---------------------------------------------------------------

# l = iTuple([s])

# print(l.extend([2]))

# print(l.append(1))

# print(l.map(print))

# # ---------------------------------------------------------------

# print(s.cls)

# print(&#34;Should be true:&#34;, nTuple.is_instance(s))
# print(&#34;Should be false:&#34;, nTuple.is_subclass(s))

# print(&#34;Should be true:&#34;, nTuple.is_subclass(S))
# print(&#34;Should be false:&#34;, nTuple.is_instance(S))

# ---------------------------------------------------------------

# NOTE: i coudl in theory generate sqlalchemy tables

# based on the struct definition

# joins presumably are then manual?

# with standardised eg. persist methods based on unique keys, etc.

# but any point?

# handle dates as tiny structs?
# surely prohibitively expensive

# tuples perhaps not? but still a bit, and all the datetime methods suddenly wouldn&#39;t work.

# ---------------------------------------------------------------</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="xtuples.cast_json"><code class="name flex">
<span>def <span class="ident">cast_json</span></span>(<span>obj, default=&lt;function &lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cast_json(obj, default = lambda obj: obj):
    if nTuple.is_instance(obj):
        return nTuple.cast_json(obj)
    try:
        return obj.cast_json()
    except:
        return default(obj)</code></pre>
</details>
</dd>
<dt id="xtuples.dump_json"><code class="name flex">
<span>def <span class="ident">dump_json</span></span>(<span>f, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_json(f, v):
    return json.dump(f, v, cls=JSONEncoder)</code></pre>
</details>
</dd>
<dt id="xtuples.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>v: str, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; ex = iTuple([Example(1, &quot;a&quot;)])
&gt;&gt;&gt; from_json(ex.pipe(to_json))
iTuple(Example(x=1, s='a', it=iTuple()))
&gt;&gt;&gt; from_json(
...     iTuple([iTuple([Example(1, &quot;a&quot;)])]).pipe(to_json)
... )
iTuple(iTuple(Example(x=1, s='a', it=iTuple())))
&gt;&gt;&gt; from_json(
...     Example(2, &quot;b&quot;, iTuple([
...         iTuple([Example(1, &quot;a&quot;)])
...     ])).pipe(to_json)
... )
Example(x=2, s='b', it=iTuple(iTuple(Example(x=1, s='a', it=iTuple()))))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(v: str, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; ex = iTuple([Example(1, &#34;a&#34;)])
    &gt;&gt;&gt; from_json(ex.pipe(to_json))
    iTuple(Example(x=1, s=&#39;a&#39;, it=iTuple()))
    &gt;&gt;&gt; from_json(
    ...     iTuple([iTuple([Example(1, &#34;a&#34;)])]).pipe(to_json)
    ... )
    iTuple(iTuple(Example(x=1, s=&#39;a&#39;, it=iTuple())))
    &gt;&gt;&gt; from_json(
    ...     Example(2, &#34;b&#34;, iTuple([
    ...         iTuple([Example(1, &#34;a&#34;)])
    ...     ])).pipe(to_json)
    ... )
    Example(x=2, s=&#39;b&#39;, it=iTuple(iTuple(Example(x=1, s=&#39;a&#39;, it=iTuple()))))
    &#34;&#34;&#34;
    return json.loads(v, cls=JSONDecoder, **kwargs)</code></pre>
</details>
</dd>
<dt id="xtuples.load_json"><code class="name flex">
<span>def <span class="ident">load_json</span></span>(<span>f)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_json(f):
    return json.load(f, cls=JSONDecoder)</code></pre>
</details>
</dd>
<dt id="xtuples.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>v, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; print(iTuple([Example(1, &quot;a&quot;)]).pipe(to_json, indent=2))
{
  &quot;__t__&quot;: &quot;iTuple&quot;,
  &quot;data&quot;: [
    {
      &quot;x&quot;: 1,
      &quot;s&quot;: &quot;a&quot;,
      &quot;it&quot;: {
        &quot;__t__&quot;: &quot;iTuple&quot;,
        &quot;data&quot;: []
      },
      &quot;__t__&quot;: &quot;Example&quot;
    }
  ]
}
&gt;&gt;&gt; print(iTuple([
...     iTuple([Example(1, &quot;a&quot;)])
... ]).pipe(to_json, indent=2))
{
  &quot;__t__&quot;: &quot;iTuple&quot;,
  &quot;data&quot;: [
    {
      &quot;__t__&quot;: &quot;iTuple&quot;,
      &quot;data&quot;: [
        {
          &quot;x&quot;: 1,
          &quot;s&quot;: &quot;a&quot;,
          &quot;it&quot;: {
            &quot;__t__&quot;: &quot;iTuple&quot;,
            &quot;data&quot;: []
          },
          &quot;__t__&quot;: &quot;Example&quot;
        }
      ]
    }
  ]
}
&gt;&gt;&gt; print(Example(2, &quot;b&quot;, iTuple([
...     iTuple([Example(1, &quot;a&quot;)])
... ])).pipe(to_json, indent=2))
{
  &quot;x&quot;: 2,
  &quot;s&quot;: &quot;b&quot;,
  &quot;it&quot;: {
    &quot;__t__&quot;: &quot;iTuple&quot;,
    &quot;data&quot;: [
      {
        &quot;__t__&quot;: &quot;iTuple&quot;,
        &quot;data&quot;: [
          {
            &quot;x&quot;: 1,
            &quot;s&quot;: &quot;a&quot;,
            &quot;it&quot;: {
              &quot;__t__&quot;: &quot;iTuple&quot;,
              &quot;data&quot;: []
            },
            &quot;__t__&quot;: &quot;Example&quot;
          }
        ]
      }
    ]
  },
  &quot;__t__&quot;: &quot;Example&quot;
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(v, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; print(iTuple([Example(1, &#34;a&#34;)]).pipe(to_json, indent=2))
    {
      &#34;__t__&#34;: &#34;iTuple&#34;,
      &#34;data&#34;: [
        {
          &#34;x&#34;: 1,
          &#34;s&#34;: &#34;a&#34;,
          &#34;it&#34;: {
            &#34;__t__&#34;: &#34;iTuple&#34;,
            &#34;data&#34;: []
          },
          &#34;__t__&#34;: &#34;Example&#34;
        }
      ]
    }
    &gt;&gt;&gt; print(iTuple([
    ...     iTuple([Example(1, &#34;a&#34;)])
    ... ]).pipe(to_json, indent=2))
    {
      &#34;__t__&#34;: &#34;iTuple&#34;,
      &#34;data&#34;: [
        {
          &#34;__t__&#34;: &#34;iTuple&#34;,
          &#34;data&#34;: [
            {
              &#34;x&#34;: 1,
              &#34;s&#34;: &#34;a&#34;,
              &#34;it&#34;: {
                &#34;__t__&#34;: &#34;iTuple&#34;,
                &#34;data&#34;: []
              },
              &#34;__t__&#34;: &#34;Example&#34;
            }
          ]
        }
      ]
    }
    &gt;&gt;&gt; print(Example(2, &#34;b&#34;, iTuple([
    ...     iTuple([Example(1, &#34;a&#34;)])
    ... ])).pipe(to_json, indent=2))
    {
      &#34;x&#34;: 2,
      &#34;s&#34;: &#34;b&#34;,
      &#34;it&#34;: {
        &#34;__t__&#34;: &#34;iTuple&#34;,
        &#34;data&#34;: [
          {
            &#34;__t__&#34;: &#34;iTuple&#34;,
            &#34;data&#34;: [
              {
                &#34;x&#34;: 1,
                &#34;s&#34;: &#34;a&#34;,
                &#34;it&#34;: {
                  &#34;__t__&#34;: &#34;iTuple&#34;,
                  &#34;data&#34;: []
                },
                &#34;__t__&#34;: &#34;Example&#34;
              }
            ]
          }
        ]
      },
      &#34;__t__&#34;: &#34;Example&#34;
    }
    &#34;&#34;&#34;
    return json.dumps(v, cls=JSONEncoder, **kwargs)</code></pre>
</details>
</dd>
<dt id="xtuples.uncast_json"><code class="name flex">
<span>def <span class="ident">uncast_json</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uncast_json(obj):
    if not isinstance(obj, dict):
        return obj
    __t__ = obj.get(&#34;__t__&#34;, None)
    if __t__ is None:
        return obj
    cls = iTuple if __t__ == &#34;iTuple&#34; else REGISTRY[__t__]
    if hasattr(cls, &#34;uncast_json&#34;):
        return cls.uncast_json(obj)
    return cls(
        *(v for k, v in obj.items() if k != &#34;__t__&#34;)
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xtuples.Example"><code class="flex name class">
<span>class <span class="ident">Example</span></span>
<span>(</span><span>x: int, s: str, it: <a title="xtuples.iTuple" href="#xtuples.iTuple">iTuple</a> = iTuple())</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; ex = Example(1, &quot;a&quot;)
&gt;&gt;&gt; ex
Example(x=1, s='a', it=iTuple())
&gt;&gt;&gt; ex.cls
&lt;class 'xtuples.xtuples.nTuple'&gt;
&gt;&gt;&gt; ex.pipe(lambda nt: nt.x)
1
&gt;&gt;&gt; f = ex.partial(lambda nt, v: nt.x * v)
&gt;&gt;&gt; f(2)
2
&gt;&gt;&gt; f(3)
3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@nTuple.decorate
class Example(typing.NamedTuple):
    &#34;&#34;&#34;
    &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
    &gt;&gt;&gt; ex
    Example(x=1, s=&#39;a&#39;, it=iTuple())
    &gt;&gt;&gt; ex.cls
    &lt;class &#39;xtuples.xtuples.nTuple&#39;&gt;
    &gt;&gt;&gt; ex.pipe(lambda nt: nt.x)
    1
    &gt;&gt;&gt; f = ex.partial(lambda nt, v: nt.x * v)
    &gt;&gt;&gt; f(2)
    2
    &gt;&gt;&gt; f(3)
    3
    &#34;&#34;&#34;
    # NOTE: cls, pipe, partial are mandatory boilerplate

    x: int
    s: str
    it: iTuple = iTuple([])

    @property
    def cls(self):
        ...

    def pipe(self, f, *args, **kwargs):
        ...

    def partial(self, f, *args, **kwargs):
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xtuples.Example.cls"><code class="name">var <span class="ident">cls</span></code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xtuples.Example.it"><code class="name">var <span class="ident">it</span> : <a title="xtuples.iTuple" href="#xtuples.iTuple">iTuple</a></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="xtuples.Example.s"><code class="name">var <span class="ident">s</span> : str</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="xtuples.Example.x"><code class="name">var <span class="ident">x</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xtuples.Example.partial"><code class="name flex">
<span>def <span class="ident">partial</span></span>(<span>obj, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def partial(obj, f, *args, **kwargs):
    return functools.partial(f, obj, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="xtuples.Example.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>obj, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pipe(obj, f, *args, **kwargs):
    return f(obj, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xtuples.JSONDecoder"><code class="flex name class">
<span>class <span class="ident">JSONDecoder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple JSON <a href="http://json.org">http://json.org</a> decoder</p>
<p>Performs the following translations in decoding by default:</p>
<p>+---------------+-------------------+
| JSON
| Python
|
+===============+===================+
| object
| dict
|
+---------------+-------------------+
| array
| list
|
+---------------+-------------------+
| string
| str
|
+---------------+-------------------+
| number (int)
| int
|
+---------------+-------------------+
| number (real) | float
|
+---------------+-------------------+
| true
| True
|
+---------------+-------------------+
| false
| False
|
+---------------+-------------------+
| null
| None
|
+---------------+-------------------+</p>
<p>It also understands <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code> as
their corresponding <code>float</code> values, which is outside the JSON spec.</p>
<p><code>object_hook</code>, if specified, will be called with the result
of every JSON object decoded and its return value will be used in
place of the given <code>dict</code>.
This can be used to provide custom
deserializations (e.g. to support JSON-RPC class hinting).</p>
<p><code>object_pairs_hook</code>, if specified will be called with the result of
every JSON object decoded with an ordered list of pairs.
The return
value of <code>object_pairs_hook</code> will be used instead of the <code>dict</code>.
This feature can be used to implement custom decoders.
If <code>object_hook</code> is also defined, the <code>object_pairs_hook</code> takes
priority.</p>
<p><code>parse_float</code>, if specified, will be called with the string
of every JSON float to be decoded. By default this is equivalent to
float(num_str). This can be used to use another datatype or parser
for JSON floats (e.g. decimal.Decimal).</p>
<p><code>parse_int</code>, if specified, will be called with the string
of every JSON int to be decoded. By default this is equivalent to
int(num_str). This can be used to use another datatype or parser
for JSON integers (e.g. float).</p>
<p><code>parse_constant</code>, if specified, will be called with one of the
following strings: -Infinity, Infinity, NaN.
This can be used to raise an exception if invalid JSON numbers
are encountered.</p>
<p>If <code>strict</code> is false (true is the default), then control
characters will be allowed inside strings.
Control characters in
this context are those with character codes in the 0-31 range,
including <code>'\t'</code> (tab), <code>'\n'</code>, <code>'\r'</code> and <code>'\0'</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONDecoder(json.JSONDecoder):

    def __init__(self, *args, **kwargs):
        json.JSONDecoder.__init__(
            self,
            object_hook=self.object_hook,
            *args,
            **kwargs
            #
        )

    @classmethod
    def xtuple_object_hook(cls, d):
        return uncast_json(d)

    def object_hook(self, d):
        return self.xtuple_object_hook(d)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>json.decoder.JSONDecoder</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="xtuples.JSONDecoder.xtuple_object_hook"><code class="name flex">
<span>def <span class="ident">xtuple_object_hook</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def xtuple_object_hook(cls, d):
    return uncast_json(d)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xtuples.JSONDecoder.object_hook"><code class="name flex">
<span>def <span class="ident">object_hook</span></span>(<span>self, d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_hook(self, d):
    return self.xtuple_object_hook(d)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xtuples.JSONEncoder"><code class="flex name class">
<span>class <span class="ident">JSONEncoder</span></span>
<span>(</span><span>*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Extensible JSON <a href="http://json.org">http://json.org</a> encoder for Python data structures.</p>
<p>Supports the following objects and types by default:</p>
<p>+-------------------+---------------+
| Python
| JSON
|
+===================+===============+
| dict
| object
|
+-------------------+---------------+
| list, tuple
| array
|
+-------------------+---------------+
| str
| string
|
+-------------------+---------------+
| int, float
| number
|
+-------------------+---------------+
| True
| true
|
+-------------------+---------------+
| False
| false
|
+-------------------+---------------+
| None
| null
|
+-------------------+---------------+</p>
<p>To extend this to recognize other objects, subclass and implement a
<code>.default()</code> method with another method that returns a serializable
object for <code>o</code> if possible, otherwise it should call the superclass
implementation (to raise <code>TypeError</code>).</p>
<p>Constructor for JSONEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, float or None.
If
skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming non-ASCII characters escaped.
If
ensure_ascii is false, the output can contain non-ASCII characters.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an OverflowError).
Otherwise, no such check takes place.</p>
<p>If allow_nan is true, then NaN, Infinity, and -Infinity will be
encoded as such.
This behavior is not JSON specification compliant,
but is consistent with most JavaScript based encoders and decoders.
Otherwise, it will be a ValueError to encode such floats.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a non-negative integer, then JSON array
elements and object members will be pretty-printed with that
indent level.
An indent level of 0 will only insert newlines.
None is the most compact representation.</p>
<p>If specified, separators should be an (item_separator, key_separator)
tuple.
The default is (', ', ': ') if <em>indent</em> is <code>None</code> and
(',', ': ') otherwise.
To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.
It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONEncoder(json.JSONEncoder):

    def iterencode(self, o, *args, **kwargs):
        for chunk in super().iterencode(
            cast_json(o), *args, **kwargs
        ):
            yield chunk</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>json.encoder.JSONEncoder</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="xtuples.JSONEncoder.iterencode"><code class="name flex">
<span>def <span class="ident">iterencode</span></span>(<span>self, o, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the given object and yield each string
representation as available.</p>
<p>For example::</p>
<pre><code>for chunk in JSONEncoder().iterencode(bigobject):
    mysocket.write(chunk)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterencode(self, o, *args, **kwargs):
    for chunk in super().iterencode(
        cast_json(o), *args, **kwargs
    ):
        yield chunk</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xtuples.fDict"><code class="flex name class">
<span>class <span class="ident">fDict</span></span>
<span>(</span><span>dict=None, /, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class fDict(collections.UserDict):
    __slots__ = ()

    data: dict

    def pipe(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).pipe(lambda d: d.map_values(
        ...     lambda v: v + 1
        ... ))
        {0: 2}
        &#34;&#34;&#34;
        res = f(self, *args, **kwargs)
        if isinstance(res, dict):
            return fDict(res)
        return res

    def partial(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; f = fDict({0: 1}).partial(
        ...     lambda d, n: d.map_values(lambda v: v + n)
        ... )
        &gt;&gt;&gt; f(1)
        {0: 2}
        &gt;&gt;&gt; f(2)
        {0: 3}
        &#34;&#34;&#34;
        return functools.partial(f, self, *args, **kwargs)

    def keys_tuple(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).keys_tuple()
        iTuple(0)
        &#34;&#34;&#34;
        return iTuple.from_keys(self)

    def values_tuple(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).values_tuple()
        iTuple(1)
        &#34;&#34;&#34;
        return iTuple.from_values(self)
    
    def items_tuple(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).items_tuple()
        iTuple((0, 1))
        &#34;&#34;&#34;
        return iTuple.from_items(self)

    # NOTE: we have separate map implementations 
    # as they are constant size, dict to dict
    # other iterator functions should use iTuple (from the above)

    def map_keys(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).map_keys(lambda v: v + 1)
        {1: 1}
        &#34;&#34;&#34;
        return fDict(
            (f(k, *args, **kwargs), v) for k, v in self.items()
        )

    def map_values(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).map_values(lambda v: v + 1)
        {0: 2}
        &#34;&#34;&#34;
        return fDict(
            (k, f(v, *args, **kwargs)) for k, v in self.items()
        )

    def map_items(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).map_items(lambda k, v: (v, k))
        {1: 0}
        &#34;&#34;&#34;
        return fDict(
            f(k, v, *args, **kwargs) for k, v in self.items()
        )

    def invert(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; fDict({0: 1}).invert()
        {1: 0}
        &#34;&#34;&#34;
        return fDict((v, k) for k, v in self.items())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.UserDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xtuples.fDict.data"><code class="name">var <span class="ident">data</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xtuples.fDict.invert"><code class="name flex">
<span>def <span class="ident">invert</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).invert()
{1: 0}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).invert()
    {1: 0}
    &#34;&#34;&#34;
    return fDict((v, k) for k, v in self.items())</code></pre>
</details>
</dd>
<dt id="xtuples.fDict.items_tuple"><code class="name flex">
<span>def <span class="ident">items_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).items_tuple()
iTuple((0, 1))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items_tuple(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).items_tuple()
    iTuple((0, 1))
    &#34;&#34;&#34;
    return iTuple.from_items(self)</code></pre>
</details>
</dd>
<dt id="xtuples.fDict.keys_tuple"><code class="name flex">
<span>def <span class="ident">keys_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).keys_tuple()
iTuple(0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys_tuple(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).keys_tuple()
    iTuple(0)
    &#34;&#34;&#34;
    return iTuple.from_keys(self)</code></pre>
</details>
</dd>
<dt id="xtuples.fDict.map_items"><code class="name flex">
<span>def <span class="ident">map_items</span></span>(<span>self, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).map_items(lambda k, v: (v, k))
{1: 0}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_items(self, f, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).map_items(lambda k, v: (v, k))
    {1: 0}
    &#34;&#34;&#34;
    return fDict(
        f(k, v, *args, **kwargs) for k, v in self.items()
    )</code></pre>
</details>
</dd>
<dt id="xtuples.fDict.map_keys"><code class="name flex">
<span>def <span class="ident">map_keys</span></span>(<span>self, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).map_keys(lambda v: v + 1)
{1: 1}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_keys(self, f, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).map_keys(lambda v: v + 1)
    {1: 1}
    &#34;&#34;&#34;
    return fDict(
        (f(k, *args, **kwargs), v) for k, v in self.items()
    )</code></pre>
</details>
</dd>
<dt id="xtuples.fDict.map_values"><code class="name flex">
<span>def <span class="ident">map_values</span></span>(<span>self, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).map_values(lambda v: v + 1)
{0: 2}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_values(self, f, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).map_values(lambda v: v + 1)
    {0: 2}
    &#34;&#34;&#34;
    return fDict(
        (k, f(v, *args, **kwargs)) for k, v in self.items()
    )</code></pre>
</details>
</dd>
<dt id="xtuples.fDict.partial"><code class="name flex">
<span>def <span class="ident">partial</span></span>(<span>self, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; f = fDict({0: 1}).partial(
...     lambda d, n: d.map_values(lambda v: v + n)
... )
&gt;&gt;&gt; f(1)
{0: 2}
&gt;&gt;&gt; f(2)
{0: 3}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partial(self, f, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; f = fDict({0: 1}).partial(
    ...     lambda d, n: d.map_values(lambda v: v + n)
    ... )
    &gt;&gt;&gt; f(1)
    {0: 2}
    &gt;&gt;&gt; f(2)
    {0: 3}
    &#34;&#34;&#34;
    return functools.partial(f, self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="xtuples.fDict.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).pipe(lambda d: d.map_values(
...     lambda v: v + 1
... ))
{0: 2}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, f, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).pipe(lambda d: d.map_values(
    ...     lambda v: v + 1
    ... ))
    {0: 2}
    &#34;&#34;&#34;
    res = f(self, *args, **kwargs)
    if isinstance(res, dict):
        return fDict(res)
    return res</code></pre>
</details>
</dd>
<dt id="xtuples.fDict.values_tuple"><code class="name flex">
<span>def <span class="ident">values_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; fDict({0: 1}).values_tuple()
iTuple(1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values_tuple(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; fDict({0: 1}).values_tuple()
    iTuple(1)
    &#34;&#34;&#34;
    return iTuple.from_values(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xtuples.iTuple"><code class="flex name class">
<span>class <span class="ident">iTuple</span></span>
<span>(</span><span>data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>iTuple(data=None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass(init = False, repr=True)
class iTuple(collections.UserList, tuple): # type: ignore
    __slots__ = ()

    data: tuple # type: ignore

    # -----

    @staticmethod
    def __new__(cls, data = None):
        # NOTE: we use cls not array
        # so sub-classing *does* change identity
        if isinstance(data, cls):
            return data
        return super().__new__(cls, data=data)

    @staticmethod
    def wrap_tuple(data):
        return data if isinstance(data, tuple) else tuple(data)
    
    def __init__(self, data = None):
        # TODO: option for lazy init?
        self.data = (
            tuple() if data is None
            else self.wrap_tuple(data)
        )

    def __repr__(self):
        s = super().__repr__()
        return &#34;{}({})&#34;.format(
            type(self).__name__,
            s[1:-2 if s[-2] == &#34;,&#34; else -1],
        )

    def __hash__(self):
        return hash(self.data)

    @classmethod
    def decorate(meta, cls):
        assert cls.__name__ not in REGISTRY
        REGISTRY[cls.__name__] = cls
        return cls

    # -----

    def cast_json(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).cast_json()
        {&#39;__t__&#39;: &#39;iTuple&#39;, &#39;data&#39;: [0]}
        &#34;&#34;&#34;
        return dict(
            __t__ = type(self).__name__,
            data = list(self.map(cast_json)),
        )

    @classmethod
    def uncast_json(cls, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.uncast_json(iTuple.range(1).cast_json())
        iTuple(0)
        &#34;&#34;&#34;
        assert obj[&#34;__t__&#34;] == cls.__name__
        return cls(data=obj[&#34;data&#34;])

    # -----

    @classmethod
    def range(cls, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3)
        iTuple(0, 1, 2)
        &#34;&#34;&#34;
        return cls(range(*args, **kwargs))

    @classmethod
    def from_keys(cls, d):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.from_keys({i: i + 1 for i in range(2)})
        iTuple(0, 1)
        &#34;&#34;&#34;
        return cls(d.keys())
        
    @classmethod
    def from_values(cls, d):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.from_values({i: i + 1 for i in range(2)})
        iTuple(1, 2)
        &#34;&#34;&#34;
        return cls(d.values())
        
    @classmethod
    def from_items(cls, d):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.from_items({i: i + 1 for i in range(2)})
        iTuple((0, 1), (1, 2))
        &#34;&#34;&#34;
        return cls(d.items())

    # -----

    def pipe(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(2).pipe(lambda it: it)
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(2).pipe(
        ...     lambda it, v: it.map(lambda x: x * v), 2
        ... )
        iTuple(0, 2)
        &#34;&#34;&#34;
        return f(self, *args, **kwargs)

    def partial(self, f, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; f = iTuple.range(2).partial(
        ...     lambda it, v: it.map(lambda x: x * v)
        ... )
        &gt;&gt;&gt; f(2)
        iTuple(0, 2)
        &gt;&gt;&gt; f(3)
        iTuple(0, 3)
        &#34;&#34;&#34;
        return functools.partial(f, self, *args, **kwargs)

    # -----

    def len(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).len()
        3
        &#34;&#34;&#34;
        return len(self)

    def append(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).append(1)
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(1).append(1, 2)
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(1).append(1, 2, 3)
        iTuple(0, 1, 2, 3)
        &gt;&gt;&gt; iTuple.range(1).append(1, (2,))
        iTuple(0, 1, (2,))
        &#34;&#34;&#34;
        return self + (value, *values)

    def prepend(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).prepend(1)
        iTuple(1, 0)
        &gt;&gt;&gt; iTuple.range(1).prepend(1, 2)
        iTuple(1, 2, 0)
        &gt;&gt;&gt; iTuple.range(1).prepend(1, 2, 3)
        iTuple(1, 2, 3, 0)
        &gt;&gt;&gt; iTuple.range(1).prepend(1, (2,))
        iTuple(1, (2,), 0)
        &#34;&#34;&#34;
        return (value, *values) + self

    def zip(self, *itrs, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple([[1, 1], [2, 2], [3, 3]]).zip()
        iTuple((1, 2, 3), (1, 2, 3))
        &gt;&gt;&gt; iTuple([iTuple.range(3), iTuple.range(1, 4)]).zip()
        iTuple((0, 1), (1, 2), (2, 3))
        &gt;&gt;&gt; iTuple.range(3).zip(iTuple.range(1, 4))
        iTuple((0, 1), (1, 2), (2, 3))
        &#34;&#34;&#34;
        if len(itrs) == 0:
            res = zip(*self)
        else:
            res = zip(self, *itrs)
        return res if lazy else iTuple(data=res)

    def flatten(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).map(lambda x: [x]).flatten()
        iTuple(0, 1, 2)
        &#34;&#34;&#34;
        return iTuple(itertools.chain(*self))

    def extend(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).extend((1,))
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(1).extend([1])
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(1).extend([1], [2])
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(1).extend([1], [[2]])
        iTuple(0, 1, [2])
        &gt;&gt;&gt; iTuple.range(1).extend([1], [[2]], [2])
        iTuple(0, 1, [2], 2)
        &#34;&#34;&#34;
        return iTuple(itertools.chain.from_iterable(
            (self, value, *values)
        ))

    def pretend(self, value, *values):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(1).pretend((1,))
        iTuple(1, 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1])
        iTuple(1, 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1], [2])
        iTuple(1, 2, 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]])
        iTuple(1, [2], 0)
        &gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]], [2])
        iTuple(1, [2], 2, 0)
        &#34;&#34;&#34;
        return iTuple(itertools.chain.from_iterable(
            (value, *values, self)
        ))

    def filter_eq(self, v, f = None, eq = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).filter_eq(1)
        iTuple(1)
        &#34;&#34;&#34;
        if f is None and eq is None:
            res = filter(lambda x: x == v, self)
        elif f is not None:
            res = filter(lambda x: f(x) == v, self)
        elif eq is not None:
            res = filter(lambda x: eq(x, v), self)
        else:
            res = filter(lambda x: eq(f(x), v), self)
        return res if lazy else type(self)(data=res)

    def filter(self, f, eq = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).filter(lambda x: x &gt; 1)
        iTuple(2)
        &#34;&#34;&#34;
        return self.filter_eq(True, f = f, eq = eq, lazy = lazy)

    def map(self, f, *iterables, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).map(lambda x: x * 2)
        iTuple(0, 2, 4)
        &#34;&#34;&#34;
        res = map(f, self, *iterables)
        return res if lazy else iTuple(data=res)

    def enumerate(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).enumerate()
        iTuple((0, 0), (1, 1), (2, 2))
        &#34;&#34;&#34;
        # TODO: allow lazy
        return iTuple(enumerate(self))

    def groupby(
        self, 
        f, 
        lazy = False, 
        keys = False,
        pipe= None,
    ):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).groupby(lambda x: x &lt; 2)
        iTuple((0, 1), (2,))
        &gt;&gt;&gt; iTuple.range(3).groupby(
        ...    lambda x: x &lt; 2, keys=True, pipe=fDict
        ... )
        {True: (0, 1), False: (2,)}
        &#34;&#34;&#34;
        # TODO: lazy no keys
        res = itertools.groupby(self, key=f)
        if lazy and keys and pipe is None:
            return res
        if pipe is None:
            pipe = iTuple
        if keys:
            return pipe((k, tuple(g),) for k, g in res)
        else:
            return pipe(tuple(g) for k, g in res)

    def first(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).first()
        0
        &#34;&#34;&#34;
        return self[0]
    
    def last(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).last()
        2
        &#34;&#34;&#34;
        return self[-1]

    def first_where(self, f):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).first_where(lambda v: v &gt; 0)
        1
        &#34;&#34;&#34;
        for v in self:
            if f(v):
                return v
        return None

    def last_where(self, f):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).last_where(lambda v: v &lt; 2)
        1
        &#34;&#34;&#34;
        for v in reversed(self):
            if f(v):
                return v
        return None

    def take(self, n):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).take(2)
        iTuple(0, 1)
        &#34;&#34;&#34;
        return self[:n]

    def tail(self, n):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).tail(2)
        iTuple(1, 2)
        &#34;&#34;&#34;
        return self[-n:]

    def reverse(self, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).reverse()
        iTuple(2, 1, 0)
        &#34;&#34;&#34;
        if lazy:
            return reversed(self)
        return type(self)(data=reversed(self))

    def take_while(self, f, n = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).take_while(lambda v: v &lt; 1)
        iTuple(0)
        &#34;&#34;&#34;
        def iter():
            i = 0
            for v in self:
                if f(v) and (n is None or i &lt; n):
                    yield v
                    i += 1
                else:
                    return
        res = iter()
        return res if lazy else type(self)(data=res)

    def tail_while(self, f, n = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).tail_while(lambda v: v &gt; 1)
        iTuple(2)
        &#34;&#34;&#34;
        i = 0
        for v in reversed(self):
            if f(v) and (n is None or i &lt; n):
                i += 1
            else:
                break
        return self.tail(i)

    # NOTE: from as in, starting from first true
    # versus above, which is until first false
    def take_after(self, f, n = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1)
        iTuple(1, 2)
        &gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1, n = 1)
        iTuple(1)
        &#34;&#34;&#34;
        def iter():
            i = 0
            for v in self:
                if f(v):
                    pass
                elif n is None or i &lt; n:
                    yield v
                    i += 1
                else:
                    return
        res = iter()
        return res if lazy else type(self)(data=res)

    def tail_after(self, f, n = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2)
        iTuple(0, 1)
        &gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2, 1)
        iTuple(1)
        &#34;&#34;&#34;
        l = 0
        r = 0
        for v in reversed(self):
            if not f(v):
                l += 1
            elif n is None or r &lt; n:
                r += 1
            else:
                break
        return self.tail(l + r).take(r)

    def islice(self, left = None, right = None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(5).islice(1, 3)
        iTuple(1, 2)
        &#34;&#34;&#34;
        return self[left:right]

    def unique(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple([1, 1, 3, 2, 4, 2, 3]).unique()
        iTuple(1, 3, 2, 4)
        &#34;&#34;&#34;
        def iter():
            seen = set()
            seen_add = seen.add
            seen_contains = seen.__contains__
            for v in itertools.filterfalse(seen_contains, self):
                seen_add(v)
                yield v
        return type(self)(data=iter())
    
    def sort(self, f = lambda v: v):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).reverse().sort()
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).sort()
        iTuple(0, 1, 2)
        &#34;&#34;&#34;
        return type(self)(data=sorted(self, key = f))

    def accumulate(self, f, initial = None, lazy = False):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v)
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v, initial=0)
        iTuple(0, 0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).accumulate(operator.add)
        iTuple(0, 1, 3)
        &#34;&#34;&#34;
        res = itertools.accumulate(self, func=f, initial=initial)
        return res if lazy else iTuple(data=res)

    def foldcum(self, *args, **kwargs):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).foldcum(lambda acc, v: v)
        iTuple(0, 1, 2)
        &gt;&gt;&gt; iTuple.range(3).foldcum(operator.add)
        iTuple(0, 1, 3)
        &#34;&#34;&#34;
        return self.accumulate(*args, **kwargs)

    def fold(self, f, initial=None):
        &#34;&#34;&#34;
        &gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v)
        2
        &gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v, initial=0)
        2
        &gt;&gt;&gt; iTuple.range(3).fold(operator.add)
        3
        &#34;&#34;&#34;
        if initial is not None:
            res = functools.reduce(f, self, initial)
        else:
            res = functools.reduce(f, self)
        return res</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.UserList</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li>builtins.tuple</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xtuples.iTuple.data"><code class="name">var <span class="ident">data</span> : tuple</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="xtuples.iTuple.decorate"><code class="name flex">
<span>def <span class="ident">decorate</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def decorate(meta, cls):
    assert cls.__name__ not in REGISTRY
    REGISTRY[cls.__name__] = cls
    return cls</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.from_items"><code class="name flex">
<span>def <span class="ident">from_items</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.from_items({i: i + 1 for i in range(2)})
iTuple((0, 1), (1, 2))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_items(cls, d):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.from_items({i: i + 1 for i in range(2)})
    iTuple((0, 1), (1, 2))
    &#34;&#34;&#34;
    return cls(d.items())</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.from_keys"><code class="name flex">
<span>def <span class="ident">from_keys</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.from_keys({i: i + 1 for i in range(2)})
iTuple(0, 1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_keys(cls, d):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.from_keys({i: i + 1 for i in range(2)})
    iTuple(0, 1)
    &#34;&#34;&#34;
    return cls(d.keys())</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.from_values"><code class="name flex">
<span>def <span class="ident">from_values</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.from_values({i: i + 1 for i in range(2)})
iTuple(1, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_values(cls, d):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.from_values({i: i + 1 for i in range(2)})
    iTuple(1, 2)
    &#34;&#34;&#34;
    return cls(d.values())</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3)
iTuple(0, 1, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def range(cls, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3)
    iTuple(0, 1, 2)
    &#34;&#34;&#34;
    return cls(range(*args, **kwargs))</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.uncast_json"><code class="name flex">
<span>def <span class="ident">uncast_json</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.uncast_json(iTuple.range(1).cast_json())
iTuple(0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def uncast_json(cls, obj):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.uncast_json(iTuple.range(1).cast_json())
    iTuple(0)
    &#34;&#34;&#34;
    assert obj[&#34;__t__&#34;] == cls.__name__
    return cls(data=obj[&#34;data&#34;])</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.wrap_tuple"><code class="name flex">
<span>def <span class="ident">wrap_tuple</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def wrap_tuple(data):
    return data if isinstance(data, tuple) else tuple(data)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xtuples.iTuple.accumulate"><code class="name flex">
<span>def <span class="ident">accumulate</span></span>(<span>self, f, initial=None, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v)
iTuple(0, 1, 2)
&gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v, initial=0)
iTuple(0, 0, 1, 2)
&gt;&gt;&gt; iTuple.range(3).accumulate(operator.add)
iTuple(0, 1, 3)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accumulate(self, f, initial = None, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v)
    iTuple(0, 1, 2)
    &gt;&gt;&gt; iTuple.range(3).accumulate(lambda acc, v: v, initial=0)
    iTuple(0, 0, 1, 2)
    &gt;&gt;&gt; iTuple.range(3).accumulate(operator.add)
    iTuple(0, 1, 3)
    &#34;&#34;&#34;
    res = itertools.accumulate(self, func=f, initial=initial)
    return res if lazy else iTuple(data=res)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, value, *values)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(1).append(1)
iTuple(0, 1)
&gt;&gt;&gt; iTuple.range(1).append(1, 2)
iTuple(0, 1, 2)
&gt;&gt;&gt; iTuple.range(1).append(1, 2, 3)
iTuple(0, 1, 2, 3)
&gt;&gt;&gt; iTuple.range(1).append(1, (2,))
iTuple(0, 1, (2,))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, value, *values):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(1).append(1)
    iTuple(0, 1)
    &gt;&gt;&gt; iTuple.range(1).append(1, 2)
    iTuple(0, 1, 2)
    &gt;&gt;&gt; iTuple.range(1).append(1, 2, 3)
    iTuple(0, 1, 2, 3)
    &gt;&gt;&gt; iTuple.range(1).append(1, (2,))
    iTuple(0, 1, (2,))
    &#34;&#34;&#34;
    return self + (value, *values)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.cast_json"><code class="name flex">
<span>def <span class="ident">cast_json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(1).cast_json()
{'__t__': 'iTuple', 'data': [0]}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cast_json(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(1).cast_json()
    {&#39;__t__&#39;: &#39;iTuple&#39;, &#39;data&#39;: [0]}
    &#34;&#34;&#34;
    return dict(
        __t__ = type(self).__name__,
        data = list(self.map(cast_json)),
    )</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.enumerate"><code class="name flex">
<span>def <span class="ident">enumerate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).enumerate()
iTuple((0, 0), (1, 1), (2, 2))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enumerate(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).enumerate()
    iTuple((0, 0), (1, 1), (2, 2))
    &#34;&#34;&#34;
    # TODO: allow lazy
    return iTuple(enumerate(self))</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, value, *values)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(1).extend((1,))
iTuple(0, 1)
&gt;&gt;&gt; iTuple.range(1).extend([1])
iTuple(0, 1)
&gt;&gt;&gt; iTuple.range(1).extend([1], [2])
iTuple(0, 1, 2)
&gt;&gt;&gt; iTuple.range(1).extend([1], [[2]])
iTuple(0, 1, [2])
&gt;&gt;&gt; iTuple.range(1).extend([1], [[2]], [2])
iTuple(0, 1, [2], 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, value, *values):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(1).extend((1,))
    iTuple(0, 1)
    &gt;&gt;&gt; iTuple.range(1).extend([1])
    iTuple(0, 1)
    &gt;&gt;&gt; iTuple.range(1).extend([1], [2])
    iTuple(0, 1, 2)
    &gt;&gt;&gt; iTuple.range(1).extend([1], [[2]])
    iTuple(0, 1, [2])
    &gt;&gt;&gt; iTuple.range(1).extend([1], [[2]], [2])
    iTuple(0, 1, [2], 2)
    &#34;&#34;&#34;
    return iTuple(itertools.chain.from_iterable(
        (self, value, *values)
    ))</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, f, eq=None, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).filter(lambda x: x &gt; 1)
iTuple(2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, f, eq = None, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).filter(lambda x: x &gt; 1)
    iTuple(2)
    &#34;&#34;&#34;
    return self.filter_eq(True, f = f, eq = eq, lazy = lazy)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.filter_eq"><code class="name flex">
<span>def <span class="ident">filter_eq</span></span>(<span>self, v, f=None, eq=None, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).filter_eq(1)
iTuple(1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_eq(self, v, f = None, eq = None, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).filter_eq(1)
    iTuple(1)
    &#34;&#34;&#34;
    if f is None and eq is None:
        res = filter(lambda x: x == v, self)
    elif f is not None:
        res = filter(lambda x: f(x) == v, self)
    elif eq is not None:
        res = filter(lambda x: eq(x, v), self)
    else:
        res = filter(lambda x: eq(f(x), v), self)
    return res if lazy else type(self)(data=res)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.first"><code class="name flex">
<span>def <span class="ident">first</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).first()
0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).first()
    0
    &#34;&#34;&#34;
    return self[0]</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.first_where"><code class="name flex">
<span>def <span class="ident">first_where</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).first_where(lambda v: v &gt; 0)
1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_where(self, f):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).first_where(lambda v: v &gt; 0)
    1
    &#34;&#34;&#34;
    for v in self:
        if f(v):
            return v
    return None</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).map(lambda x: [x]).flatten()
iTuple(0, 1, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).map(lambda x: [x]).flatten()
    iTuple(0, 1, 2)
    &#34;&#34;&#34;
    return iTuple(itertools.chain(*self))</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self, f, initial=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v)
2
&gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v, initial=0)
2
&gt;&gt;&gt; iTuple.range(3).fold(operator.add)
3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self, f, initial=None):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v)
    2
    &gt;&gt;&gt; iTuple.range(3).fold(lambda acc, v: v, initial=0)
    2
    &gt;&gt;&gt; iTuple.range(3).fold(operator.add)
    3
    &#34;&#34;&#34;
    if initial is not None:
        res = functools.reduce(f, self, initial)
    else:
        res = functools.reduce(f, self)
    return res</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.foldcum"><code class="name flex">
<span>def <span class="ident">foldcum</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).foldcum(lambda acc, v: v)
iTuple(0, 1, 2)
&gt;&gt;&gt; iTuple.range(3).foldcum(operator.add)
iTuple(0, 1, 3)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def foldcum(self, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).foldcum(lambda acc, v: v)
    iTuple(0, 1, 2)
    &gt;&gt;&gt; iTuple.range(3).foldcum(operator.add)
    iTuple(0, 1, 3)
    &#34;&#34;&#34;
    return self.accumulate(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.groupby"><code class="name flex">
<span>def <span class="ident">groupby</span></span>(<span>self, f, lazy=False, keys=False, pipe=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).groupby(lambda x: x &lt; 2)
iTuple((0, 1), (2,))
&gt;&gt;&gt; iTuple.range(3).groupby(
...    lambda x: x &lt; 2, keys=True, pipe=fDict
... )
{True: (0, 1), False: (2,)}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groupby(
    self, 
    f, 
    lazy = False, 
    keys = False,
    pipe= None,
):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).groupby(lambda x: x &lt; 2)
    iTuple((0, 1), (2,))
    &gt;&gt;&gt; iTuple.range(3).groupby(
    ...    lambda x: x &lt; 2, keys=True, pipe=fDict
    ... )
    {True: (0, 1), False: (2,)}
    &#34;&#34;&#34;
    # TODO: lazy no keys
    res = itertools.groupby(self, key=f)
    if lazy and keys and pipe is None:
        return res
    if pipe is None:
        pipe = iTuple
    if keys:
        return pipe((k, tuple(g),) for k, g in res)
    else:
        return pipe(tuple(g) for k, g in res)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.islice"><code class="name flex">
<span>def <span class="ident">islice</span></span>(<span>self, left=None, right=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(5).islice(1, 3)
iTuple(1, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def islice(self, left = None, right = None):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(5).islice(1, 3)
    iTuple(1, 2)
    &#34;&#34;&#34;
    return self[left:right]</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).last()
2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).last()
    2
    &#34;&#34;&#34;
    return self[-1]</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.last_where"><code class="name flex">
<span>def <span class="ident">last_where</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).last_where(lambda v: v &lt; 2)
1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last_where(self, f):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).last_where(lambda v: v &lt; 2)
    1
    &#34;&#34;&#34;
    for v in reversed(self):
        if f(v):
            return v
    return None</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.len"><code class="name flex">
<span>def <span class="ident">len</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).len()
3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def len(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).len()
    3
    &#34;&#34;&#34;
    return len(self)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, f, *iterables, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).map(lambda x: x * 2)
iTuple(0, 2, 4)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, f, *iterables, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).map(lambda x: x * 2)
    iTuple(0, 2, 4)
    &#34;&#34;&#34;
    res = map(f, self, *iterables)
    return res if lazy else iTuple(data=res)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.partial"><code class="name flex">
<span>def <span class="ident">partial</span></span>(<span>self, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; f = iTuple.range(2).partial(
...     lambda it, v: it.map(lambda x: x * v)
... )
&gt;&gt;&gt; f(2)
iTuple(0, 2)
&gt;&gt;&gt; f(3)
iTuple(0, 3)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partial(self, f, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; f = iTuple.range(2).partial(
    ...     lambda it, v: it.map(lambda x: x * v)
    ... )
    &gt;&gt;&gt; f(2)
    iTuple(0, 2)
    &gt;&gt;&gt; f(3)
    iTuple(0, 3)
    &#34;&#34;&#34;
    return functools.partial(f, self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(2).pipe(lambda it: it)
iTuple(0, 1)
&gt;&gt;&gt; iTuple.range(2).pipe(
...     lambda it, v: it.map(lambda x: x * v), 2
... )
iTuple(0, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, f, *args, **kwargs):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(2).pipe(lambda it: it)
    iTuple(0, 1)
    &gt;&gt;&gt; iTuple.range(2).pipe(
    ...     lambda it, v: it.map(lambda x: x * v), 2
    ... )
    iTuple(0, 2)
    &#34;&#34;&#34;
    return f(self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.prepend"><code class="name flex">
<span>def <span class="ident">prepend</span></span>(<span>self, value, *values)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(1).prepend(1)
iTuple(1, 0)
&gt;&gt;&gt; iTuple.range(1).prepend(1, 2)
iTuple(1, 2, 0)
&gt;&gt;&gt; iTuple.range(1).prepend(1, 2, 3)
iTuple(1, 2, 3, 0)
&gt;&gt;&gt; iTuple.range(1).prepend(1, (2,))
iTuple(1, (2,), 0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepend(self, value, *values):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(1).prepend(1)
    iTuple(1, 0)
    &gt;&gt;&gt; iTuple.range(1).prepend(1, 2)
    iTuple(1, 2, 0)
    &gt;&gt;&gt; iTuple.range(1).prepend(1, 2, 3)
    iTuple(1, 2, 3, 0)
    &gt;&gt;&gt; iTuple.range(1).prepend(1, (2,))
    iTuple(1, (2,), 0)
    &#34;&#34;&#34;
    return (value, *values) + self</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.pretend"><code class="name flex">
<span>def <span class="ident">pretend</span></span>(<span>self, value, *values)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(1).pretend((1,))
iTuple(1, 0)
&gt;&gt;&gt; iTuple.range(1).pretend([1])
iTuple(1, 0)
&gt;&gt;&gt; iTuple.range(1).pretend([1], [2])
iTuple(1, 2, 0)
&gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]])
iTuple(1, [2], 0)
&gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]], [2])
iTuple(1, [2], 2, 0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretend(self, value, *values):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(1).pretend((1,))
    iTuple(1, 0)
    &gt;&gt;&gt; iTuple.range(1).pretend([1])
    iTuple(1, 0)
    &gt;&gt;&gt; iTuple.range(1).pretend([1], [2])
    iTuple(1, 2, 0)
    &gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]])
    iTuple(1, [2], 0)
    &gt;&gt;&gt; iTuple.range(1).pretend([1], [[2]], [2])
    iTuple(1, [2], 2, 0)
    &#34;&#34;&#34;
    return iTuple(itertools.chain.from_iterable(
        (value, *values, self)
    ))</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).reverse()
iTuple(2, 1, 0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse(self, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).reverse()
    iTuple(2, 1, 0)
    &#34;&#34;&#34;
    if lazy:
        return reversed(self)
    return type(self)(data=reversed(self))</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, f=&lt;function iTuple.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).reverse().sort()
iTuple(0, 1, 2)
&gt;&gt;&gt; iTuple.range(3).sort()
iTuple(0, 1, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, f = lambda v: v):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).reverse().sort()
    iTuple(0, 1, 2)
    &gt;&gt;&gt; iTuple.range(3).sort()
    iTuple(0, 1, 2)
    &#34;&#34;&#34;
    return type(self)(data=sorted(self, key = f))</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).tail(2)
iTuple(1, 2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self, n):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).tail(2)
    iTuple(1, 2)
    &#34;&#34;&#34;
    return self[-n:]</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.tail_after"><code class="name flex">
<span>def <span class="ident">tail_after</span></span>(<span>self, f, n=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2)
iTuple(0, 1)
&gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2, 1)
iTuple(1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail_after(self, f, n = None):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2)
    iTuple(0, 1)
    &gt;&gt;&gt; iTuple.range(3).tail_after(lambda v: v &lt; 2, 1)
    iTuple(1)
    &#34;&#34;&#34;
    l = 0
    r = 0
    for v in reversed(self):
        if not f(v):
            l += 1
        elif n is None or r &lt; n:
            r += 1
        else:
            break
    return self.tail(l + r).take(r)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.tail_while"><code class="name flex">
<span>def <span class="ident">tail_while</span></span>(<span>self, f, n=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).tail_while(lambda v: v &gt; 1)
iTuple(2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail_while(self, f, n = None):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).tail_while(lambda v: v &gt; 1)
    iTuple(2)
    &#34;&#34;&#34;
    i = 0
    for v in reversed(self):
        if f(v) and (n is None or i &lt; n):
            i += 1
        else:
            break
    return self.tail(i)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).take(2)
iTuple(0, 1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take(self, n):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).take(2)
    iTuple(0, 1)
    &#34;&#34;&#34;
    return self[:n]</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.take_after"><code class="name flex">
<span>def <span class="ident">take_after</span></span>(<span>self, f, n=None, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1)
iTuple(1, 2)
&gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1, n = 1)
iTuple(1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_after(self, f, n = None, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1)
    iTuple(1, 2)
    &gt;&gt;&gt; iTuple.range(3).take_after(lambda v: v &lt; 1, n = 1)
    iTuple(1)
    &#34;&#34;&#34;
    def iter():
        i = 0
        for v in self:
            if f(v):
                pass
            elif n is None or i &lt; n:
                yield v
                i += 1
            else:
                return
    res = iter()
    return res if lazy else type(self)(data=res)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.take_while"><code class="name flex">
<span>def <span class="ident">take_while</span></span>(<span>self, f, n=None, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple.range(3).take_while(lambda v: v &lt; 1)
iTuple(0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_while(self, f, n = None, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple.range(3).take_while(lambda v: v &lt; 1)
    iTuple(0)
    &#34;&#34;&#34;
    def iter():
        i = 0
        for v in self:
            if f(v) and (n is None or i &lt; n):
                yield v
                i += 1
            else:
                return
    res = iter()
    return res if lazy else type(self)(data=res)</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.unique"><code class="name flex">
<span>def <span class="ident">unique</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple([1, 1, 3, 2, 4, 2, 3]).unique()
iTuple(1, 3, 2, 4)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unique(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple([1, 1, 3, 2, 4, 2, 3]).unique()
    iTuple(1, 3, 2, 4)
    &#34;&#34;&#34;
    def iter():
        seen = set()
        seen_add = seen.add
        seen_contains = seen.__contains__
        for v in itertools.filterfalse(seen_contains, self):
            seen_add(v)
            yield v
    return type(self)(data=iter())</code></pre>
</details>
</dd>
<dt id="xtuples.iTuple.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self, *itrs, lazy=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; iTuple([[1, 1], [2, 2], [3, 3]]).zip()
iTuple((1, 2, 3), (1, 2, 3))
&gt;&gt;&gt; iTuple([iTuple.range(3), iTuple.range(1, 4)]).zip()
iTuple((0, 1), (1, 2), (2, 3))
&gt;&gt;&gt; iTuple.range(3).zip(iTuple.range(1, 4))
iTuple((0, 1), (1, 2), (2, 3))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self, *itrs, lazy = False):
    &#34;&#34;&#34;
    &gt;&gt;&gt; iTuple([[1, 1], [2, 2], [3, 3]]).zip()
    iTuple((1, 2, 3), (1, 2, 3))
    &gt;&gt;&gt; iTuple([iTuple.range(3), iTuple.range(1, 4)]).zip()
    iTuple((0, 1), (1, 2), (2, 3))
    &gt;&gt;&gt; iTuple.range(3).zip(iTuple.range(1, 4))
    iTuple((0, 1), (1, 2), (2, 3))
    &#34;&#34;&#34;
    if len(itrs) == 0:
        res = zip(*self)
    else:
        res = zip(self, *itrs)
    return res if lazy else iTuple(data=res)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xtuples.nTuple"><code class="flex name class">
<span>class <span class="ident">nTuple</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nTuple(abc.ABC):

    @abc.abstractmethod
    def __abstract__(self):
        # NOTE: here to prevent initialise instances of this
        # but rather use the decorator and typing.NamedTuple
        return

    @staticmethod
    def pipe(obj, f, *args, **kwargs):
        return f(obj, *args, **kwargs)

    @staticmethod
    def partial(obj, f, *args, **kwargs):
        return functools.partial(f, obj, *args, **kwargs)

    @classmethod
    def is_subclass(cls, t):
        &#34;&#34;&#34;
        &gt;&gt;&gt; nTuple.is_subclass(tuple)
        False
        &gt;&gt;&gt; nTuple.is_subclass(Example(1, &#34;a&#34;))
        False
        &gt;&gt;&gt; nTuple.is_subclass(Example)
        True
        &#34;&#34;&#34;
        try:
            is_sub = issubclass(t, tuple)
        except:
            is_sub = False
        return (
            is_sub and
            hasattr(t, &#34;cls&#34;) and
            hasattr(t, &#34;pipe&#34;) and
            hasattr(t, &#34;partial&#34;)
        )

    @classmethod
    def is_instance(cls, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; nTuple.is_instance(tuple)
        False
        &gt;&gt;&gt; nTuple.is_instance(Example)
        False
        &gt;&gt;&gt; nTuple.is_instance(Example(1, &#34;a&#34;))
        True
        &#34;&#34;&#34;
        return (
            cls.is_subclass(type(obj)) and
            hasattr(obj, &#39;_asdict&#39;) and
            hasattr(obj, &#39;_fields&#39;)
        )


    @staticmethod
    def annotations(obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; ex.pipe(ex.cls.annotations)
        {&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;s&#39;: &lt;class &#39;str&#39;&gt;, &#39;it&#39;: &lt;class &#39;xtuples.xtuples.iTuple&#39;&gt;}
        &#34;&#34;&#34;
        return fDict(obj.__annotations__)

    @classmethod
    def as_dict(cls, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; ex.pipe(ex.cls.as_dict)
        {&#39;x&#39;: 1, &#39;s&#39;: &#39;a&#39;, &#39;it&#39;: iTuple()}
        &#34;&#34;&#34;
        return fDict(obj._asdict())

    @classmethod
    def cast_json(cls, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; ex.pipe(ex.cls.cast_json)
        {&#39;x&#39;: 1, &#39;s&#39;: &#39;a&#39;, &#39;it&#39;: {&#39;__t__&#39;: &#39;iTuple&#39;, &#39;data&#39;: []}, &#39;__t__&#39;: &#39;Example&#39;}
        &#34;&#34;&#34;
        d = {
            k: cast_json(v)
            for k, v in obj._asdict().items()
            #
        }
        d[&#34;__t__&#34;] = type(obj).__name__
        return d

    @classmethod
    def uncast_json(meta, obj):
        &#34;&#34;&#34;
        &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
        &gt;&gt;&gt; ex.cls.uncast_json(ex.pipe(ex.cls.cast_json))
        Example(x=1, s=&#39;a&#39;, it=iTuple())
        &#34;&#34;&#34;
        cls = REGISTRY[obj[&#34;__t__&#34;]]
        return cls(
            *(
                uncast_json(v)
                for k, v in obj.items() if k != &#34;__t__&#34;
            )
        )

    @classmethod
    def decorate(meta, cls):
        assert cls.__name__ not in REGISTRY
        cls.pipe = meta.pipe
        cls.partial = meta.partial
        cls.cls = meta
        REGISTRY[cls.__name__] = cls
        return cls</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="xtuples.nTuple.annotations"><code class="name flex">
<span>def <span class="ident">annotations</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; ex = Example(1, &quot;a&quot;)
&gt;&gt;&gt; ex.pipe(ex.cls.annotations)
{'x': &lt;class 'int'&gt;, 's': &lt;class 'str'&gt;, 'it': &lt;class 'xtuples.xtuples.iTuple'&gt;}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def annotations(obj):
    &#34;&#34;&#34;
    &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
    &gt;&gt;&gt; ex.pipe(ex.cls.annotations)
    {&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;s&#39;: &lt;class &#39;str&#39;&gt;, &#39;it&#39;: &lt;class &#39;xtuples.xtuples.iTuple&#39;&gt;}
    &#34;&#34;&#34;
    return fDict(obj.__annotations__)</code></pre>
</details>
</dd>
<dt id="xtuples.nTuple.as_dict"><code class="name flex">
<span>def <span class="ident">as_dict</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; ex = Example(1, &quot;a&quot;)
&gt;&gt;&gt; ex.pipe(ex.cls.as_dict)
{'x': 1, 's': 'a', 'it': iTuple()}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def as_dict(cls, obj):
    &#34;&#34;&#34;
    &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
    &gt;&gt;&gt; ex.pipe(ex.cls.as_dict)
    {&#39;x&#39;: 1, &#39;s&#39;: &#39;a&#39;, &#39;it&#39;: iTuple()}
    &#34;&#34;&#34;
    return fDict(obj._asdict())</code></pre>
</details>
</dd>
<dt id="xtuples.nTuple.cast_json"><code class="name flex">
<span>def <span class="ident">cast_json</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; ex = Example(1, &quot;a&quot;)
&gt;&gt;&gt; ex.pipe(ex.cls.cast_json)
{'x': 1, 's': 'a', 'it': {'__t__': 'iTuple', 'data': []}, '__t__': 'Example'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cast_json(cls, obj):
    &#34;&#34;&#34;
    &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
    &gt;&gt;&gt; ex.pipe(ex.cls.cast_json)
    {&#39;x&#39;: 1, &#39;s&#39;: &#39;a&#39;, &#39;it&#39;: {&#39;__t__&#39;: &#39;iTuple&#39;, &#39;data&#39;: []}, &#39;__t__&#39;: &#39;Example&#39;}
    &#34;&#34;&#34;
    d = {
        k: cast_json(v)
        for k, v in obj._asdict().items()
        #
    }
    d[&#34;__t__&#34;] = type(obj).__name__
    return d</code></pre>
</details>
</dd>
<dt id="xtuples.nTuple.decorate"><code class="name flex">
<span>def <span class="ident">decorate</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def decorate(meta, cls):
    assert cls.__name__ not in REGISTRY
    cls.pipe = meta.pipe
    cls.partial = meta.partial
    cls.cls = meta
    REGISTRY[cls.__name__] = cls
    return cls</code></pre>
</details>
</dd>
<dt id="xtuples.nTuple.is_instance"><code class="name flex">
<span>def <span class="ident">is_instance</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; nTuple.is_instance(tuple)
False
&gt;&gt;&gt; nTuple.is_instance(Example)
False
&gt;&gt;&gt; nTuple.is_instance(Example(1, &quot;a&quot;))
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_instance(cls, obj):
    &#34;&#34;&#34;
    &gt;&gt;&gt; nTuple.is_instance(tuple)
    False
    &gt;&gt;&gt; nTuple.is_instance(Example)
    False
    &gt;&gt;&gt; nTuple.is_instance(Example(1, &#34;a&#34;))
    True
    &#34;&#34;&#34;
    return (
        cls.is_subclass(type(obj)) and
        hasattr(obj, &#39;_asdict&#39;) and
        hasattr(obj, &#39;_fields&#39;)
    )</code></pre>
</details>
</dd>
<dt id="xtuples.nTuple.is_subclass"><code class="name flex">
<span>def <span class="ident">is_subclass</span></span>(<span>t)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; nTuple.is_subclass(tuple)
False
&gt;&gt;&gt; nTuple.is_subclass(Example(1, &quot;a&quot;))
False
&gt;&gt;&gt; nTuple.is_subclass(Example)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_subclass(cls, t):
    &#34;&#34;&#34;
    &gt;&gt;&gt; nTuple.is_subclass(tuple)
    False
    &gt;&gt;&gt; nTuple.is_subclass(Example(1, &#34;a&#34;))
    False
    &gt;&gt;&gt; nTuple.is_subclass(Example)
    True
    &#34;&#34;&#34;
    try:
        is_sub = issubclass(t, tuple)
    except:
        is_sub = False
    return (
        is_sub and
        hasattr(t, &#34;cls&#34;) and
        hasattr(t, &#34;pipe&#34;) and
        hasattr(t, &#34;partial&#34;)
    )</code></pre>
</details>
</dd>
<dt id="xtuples.nTuple.partial"><code class="name flex">
<span>def <span class="ident">partial</span></span>(<span>obj, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def partial(obj, f, *args, **kwargs):
    return functools.partial(f, obj, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="xtuples.nTuple.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>obj, f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pipe(obj, f, *args, **kwargs):
    return f(obj, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="xtuples.nTuple.uncast_json"><code class="name flex">
<span>def <span class="ident">uncast_json</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; ex = Example(1, &quot;a&quot;)
&gt;&gt;&gt; ex.cls.uncast_json(ex.pipe(ex.cls.cast_json))
Example(x=1, s='a', it=iTuple())
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def uncast_json(meta, obj):
    &#34;&#34;&#34;
    &gt;&gt;&gt; ex = Example(1, &#34;a&#34;)
    &gt;&gt;&gt; ex.cls.uncast_json(ex.pipe(ex.cls.cast_json))
    Example(x=1, s=&#39;a&#39;, it=iTuple())
    &#34;&#34;&#34;
    cls = REGISTRY[obj[&#34;__t__&#34;]]
    return cls(
        *(
            uncast_json(v)
            for k, v in obj.items() if k != &#34;__t__&#34;
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="xtuples.cast_json" href="#xtuples.cast_json">cast_json</a></code></li>
<li><code><a title="xtuples.dump_json" href="#xtuples.dump_json">dump_json</a></code></li>
<li><code><a title="xtuples.from_json" href="#xtuples.from_json">from_json</a></code></li>
<li><code><a title="xtuples.load_json" href="#xtuples.load_json">load_json</a></code></li>
<li><code><a title="xtuples.to_json" href="#xtuples.to_json">to_json</a></code></li>
<li><code><a title="xtuples.uncast_json" href="#xtuples.uncast_json">uncast_json</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xtuples.Example" href="#xtuples.Example">Example</a></code></h4>
<ul class="two-column">
<li><code><a title="xtuples.Example.cls" href="#xtuples.Example.cls">cls</a></code></li>
<li><code><a title="xtuples.Example.it" href="#xtuples.Example.it">it</a></code></li>
<li><code><a title="xtuples.Example.partial" href="#xtuples.Example.partial">partial</a></code></li>
<li><code><a title="xtuples.Example.pipe" href="#xtuples.Example.pipe">pipe</a></code></li>
<li><code><a title="xtuples.Example.s" href="#xtuples.Example.s">s</a></code></li>
<li><code><a title="xtuples.Example.x" href="#xtuples.Example.x">x</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xtuples.JSONDecoder" href="#xtuples.JSONDecoder">JSONDecoder</a></code></h4>
<ul class="">
<li><code><a title="xtuples.JSONDecoder.object_hook" href="#xtuples.JSONDecoder.object_hook">object_hook</a></code></li>
<li><code><a title="xtuples.JSONDecoder.xtuple_object_hook" href="#xtuples.JSONDecoder.xtuple_object_hook">xtuple_object_hook</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xtuples.JSONEncoder" href="#xtuples.JSONEncoder">JSONEncoder</a></code></h4>
<ul class="">
<li><code><a title="xtuples.JSONEncoder.iterencode" href="#xtuples.JSONEncoder.iterencode">iterencode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xtuples.fDict" href="#xtuples.fDict">fDict</a></code></h4>
<ul class="two-column">
<li><code><a title="xtuples.fDict.data" href="#xtuples.fDict.data">data</a></code></li>
<li><code><a title="xtuples.fDict.invert" href="#xtuples.fDict.invert">invert</a></code></li>
<li><code><a title="xtuples.fDict.items_tuple" href="#xtuples.fDict.items_tuple">items_tuple</a></code></li>
<li><code><a title="xtuples.fDict.keys_tuple" href="#xtuples.fDict.keys_tuple">keys_tuple</a></code></li>
<li><code><a title="xtuples.fDict.map_items" href="#xtuples.fDict.map_items">map_items</a></code></li>
<li><code><a title="xtuples.fDict.map_keys" href="#xtuples.fDict.map_keys">map_keys</a></code></li>
<li><code><a title="xtuples.fDict.map_values" href="#xtuples.fDict.map_values">map_values</a></code></li>
<li><code><a title="xtuples.fDict.partial" href="#xtuples.fDict.partial">partial</a></code></li>
<li><code><a title="xtuples.fDict.pipe" href="#xtuples.fDict.pipe">pipe</a></code></li>
<li><code><a title="xtuples.fDict.values_tuple" href="#xtuples.fDict.values_tuple">values_tuple</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xtuples.iTuple" href="#xtuples.iTuple">iTuple</a></code></h4>
<ul class="two-column">
<li><code><a title="xtuples.iTuple.accumulate" href="#xtuples.iTuple.accumulate">accumulate</a></code></li>
<li><code><a title="xtuples.iTuple.append" href="#xtuples.iTuple.append">append</a></code></li>
<li><code><a title="xtuples.iTuple.cast_json" href="#xtuples.iTuple.cast_json">cast_json</a></code></li>
<li><code><a title="xtuples.iTuple.data" href="#xtuples.iTuple.data">data</a></code></li>
<li><code><a title="xtuples.iTuple.decorate" href="#xtuples.iTuple.decorate">decorate</a></code></li>
<li><code><a title="xtuples.iTuple.enumerate" href="#xtuples.iTuple.enumerate">enumerate</a></code></li>
<li><code><a title="xtuples.iTuple.extend" href="#xtuples.iTuple.extend">extend</a></code></li>
<li><code><a title="xtuples.iTuple.filter" href="#xtuples.iTuple.filter">filter</a></code></li>
<li><code><a title="xtuples.iTuple.filter_eq" href="#xtuples.iTuple.filter_eq">filter_eq</a></code></li>
<li><code><a title="xtuples.iTuple.first" href="#xtuples.iTuple.first">first</a></code></li>
<li><code><a title="xtuples.iTuple.first_where" href="#xtuples.iTuple.first_where">first_where</a></code></li>
<li><code><a title="xtuples.iTuple.flatten" href="#xtuples.iTuple.flatten">flatten</a></code></li>
<li><code><a title="xtuples.iTuple.fold" href="#xtuples.iTuple.fold">fold</a></code></li>
<li><code><a title="xtuples.iTuple.foldcum" href="#xtuples.iTuple.foldcum">foldcum</a></code></li>
<li><code><a title="xtuples.iTuple.from_items" href="#xtuples.iTuple.from_items">from_items</a></code></li>
<li><code><a title="xtuples.iTuple.from_keys" href="#xtuples.iTuple.from_keys">from_keys</a></code></li>
<li><code><a title="xtuples.iTuple.from_values" href="#xtuples.iTuple.from_values">from_values</a></code></li>
<li><code><a title="xtuples.iTuple.groupby" href="#xtuples.iTuple.groupby">groupby</a></code></li>
<li><code><a title="xtuples.iTuple.islice" href="#xtuples.iTuple.islice">islice</a></code></li>
<li><code><a title="xtuples.iTuple.last" href="#xtuples.iTuple.last">last</a></code></li>
<li><code><a title="xtuples.iTuple.last_where" href="#xtuples.iTuple.last_where">last_where</a></code></li>
<li><code><a title="xtuples.iTuple.len" href="#xtuples.iTuple.len">len</a></code></li>
<li><code><a title="xtuples.iTuple.map" href="#xtuples.iTuple.map">map</a></code></li>
<li><code><a title="xtuples.iTuple.partial" href="#xtuples.iTuple.partial">partial</a></code></li>
<li><code><a title="xtuples.iTuple.pipe" href="#xtuples.iTuple.pipe">pipe</a></code></li>
<li><code><a title="xtuples.iTuple.prepend" href="#xtuples.iTuple.prepend">prepend</a></code></li>
<li><code><a title="xtuples.iTuple.pretend" href="#xtuples.iTuple.pretend">pretend</a></code></li>
<li><code><a title="xtuples.iTuple.range" href="#xtuples.iTuple.range">range</a></code></li>
<li><code><a title="xtuples.iTuple.reverse" href="#xtuples.iTuple.reverse">reverse</a></code></li>
<li><code><a title="xtuples.iTuple.sort" href="#xtuples.iTuple.sort">sort</a></code></li>
<li><code><a title="xtuples.iTuple.tail" href="#xtuples.iTuple.tail">tail</a></code></li>
<li><code><a title="xtuples.iTuple.tail_after" href="#xtuples.iTuple.tail_after">tail_after</a></code></li>
<li><code><a title="xtuples.iTuple.tail_while" href="#xtuples.iTuple.tail_while">tail_while</a></code></li>
<li><code><a title="xtuples.iTuple.take" href="#xtuples.iTuple.take">take</a></code></li>
<li><code><a title="xtuples.iTuple.take_after" href="#xtuples.iTuple.take_after">take_after</a></code></li>
<li><code><a title="xtuples.iTuple.take_while" href="#xtuples.iTuple.take_while">take_while</a></code></li>
<li><code><a title="xtuples.iTuple.uncast_json" href="#xtuples.iTuple.uncast_json">uncast_json</a></code></li>
<li><code><a title="xtuples.iTuple.unique" href="#xtuples.iTuple.unique">unique</a></code></li>
<li><code><a title="xtuples.iTuple.wrap_tuple" href="#xtuples.iTuple.wrap_tuple">wrap_tuple</a></code></li>
<li><code><a title="xtuples.iTuple.zip" href="#xtuples.iTuple.zip">zip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xtuples.nTuple" href="#xtuples.nTuple">nTuple</a></code></h4>
<ul class="two-column">
<li><code><a title="xtuples.nTuple.annotations" href="#xtuples.nTuple.annotations">annotations</a></code></li>
<li><code><a title="xtuples.nTuple.as_dict" href="#xtuples.nTuple.as_dict">as_dict</a></code></li>
<li><code><a title="xtuples.nTuple.cast_json" href="#xtuples.nTuple.cast_json">cast_json</a></code></li>
<li><code><a title="xtuples.nTuple.decorate" href="#xtuples.nTuple.decorate">decorate</a></code></li>
<li><code><a title="xtuples.nTuple.is_instance" href="#xtuples.nTuple.is_instance">is_instance</a></code></li>
<li><code><a title="xtuples.nTuple.is_subclass" href="#xtuples.nTuple.is_subclass">is_subclass</a></code></li>
<li><code><a title="xtuples.nTuple.partial" href="#xtuples.nTuple.partial">partial</a></code></li>
<li><code><a title="xtuples.nTuple.pipe" href="#xtuples.nTuple.pipe">pipe</a></code></li>
<li><code><a title="xtuples.nTuple.uncast_json" href="#xtuples.nTuple.uncast_json">uncast_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>